// HTTP client
//
var http = require("http");
var https = require("https");
var url = require("url");
var zlib = require('zlib');
var stream = require('stream');
var path = require('path');
var fs = require('fs');

var foundation = require("./foundation.js");
var async = require("./async.js");
var mimes = require("./mimes.js");
var mewStream = require("./stream.js");
var storage = require("./storage.js");

var queryStringify = function (object) {

    return foundation.keys(object).map(function (key) {

        var data = "";

        if ((object[key] !== null) && (object[key] !== undefined)) {

            switch (object[key].constructor) {

                case Boolean: { data = object[key] ? "true" : "false"; break; }
                case Number: { data = object[key] + ""; break; }
                case String: { data = object[key]; break; }

                default: { data = JSON.stringify(object[key]); break; }

            }

        }

        return key + "=" + encodeURIComponent(data);

    }).join("&");

};

var HTTPClient = function HTTPClient(uri, options) {

    this.uri = uri;

    this.accumulatedErrors = 0;

    this.cookies = foundation.advancedMerge({
        "!valueType": "object",
        "!defaultValue": {}
    }, (options ? options.cookies : null));

    if (options) {
        delete options.cookies;
    }

    this.options = foundation.advancedMerge({
        "errorTimeouts": {
            "!valueType": "array",
            "!defaultValue": [0, 100, 200, 400, 800, 1600, 3200]
        }
    }, options);

};

HTTPClient.prototype.jsonrpc = function () {

    var settings = foundation.matchArguments([
        ["method", "callback"],
        ["method", "callback", "options"],
        ["method", "parameters", "callback"],
        ["method", "parameters", "callback", "options"],
    ], {
        "method": "string",
        "parameters": "array-like",
        "callback": "function",
        "options": "any"
    }, arguments);

    var data = {
        "query": JSON.stringify({
            "jsonrpc": "2.0",
            "method": settings.method,
            "params": settings.parameters ? settings.parameters : [],
            "id": new Date().getTime()
        })
    };

    if (settings.options && settings.options.file && /^data:(text|image)\/([a-zA-Z]+);base64,([A-Za-z0-9\+\/=]*)$/.test(settings.options.file)) {
        data.file = settings.options.file;
        data.fileName = settings.options.fileName;
    }

    return this.request(this.uri, {
        "data": data,
        "method": "POST",
        "onError": function (error) {
            if (settings.callback) {
                settings.callback(error);
            }
        },
        "onSuccess": function (response) {
            if (settings.callback) {
                settings.callback(response.error, response.result);
            }
        }
    });

};

HTTPClient.prototype.multipartRequest = function() {
    var settings = foundation.matchArguments([
        ["options"],
        ["uri", "options"],
    ], {
        "redirects": {
            "acceptTypes": "number",
            "defaultValue": 0
        },
        "uri": {
            "acceptTypes": "string",
            "defaultValue": this.uri
        },
        "options": {
            "acceptTypes": "object",
            "defaultValue": {},
            "mergeOptions": {

                "maxRedirects": { "!valueType": "number", "!defaultValue": 10 },

                "headers": {
                    "!defaultValue": {},
                    "Accept": { "!valueType": "string", "!defaultValue": "*/*" },
                    "User-Agent": { "!valueType": "string", "!defaultValue": "HTTP Client" },
                    "Accept-Encoding": { "!valueType": "string", "!defaultValue": "gzip, deflate" },
                    "Cookie": { "!valueType": "string", "!defaultValue": this.getCookies() }
                },

                "onError": { "!valueType": "function", "!defaultValue": function (error) { throw error; } },

                "onSuccess": { "!valueType": "function", "!defaultValue": function () {} },

                "onResponse": { "!valueType": "function", "!defaultValue": function () {} },

                "onProgress": { "!valueType": "function" },

                "timeout": { "!valueType": "number", "!defaultValue": 7500 },

                "encoding": { "!valueType": "string", "!defaultValue": "utf8" },

                "data": {
                    "!valueType": "object",
                    "!defaultValue": {},
                    "files": { "!valueType": "object", "!defaultValue": {} },
                    "body": { "!valueType": "object", "!defaultValue": {} }
                }

            }
        }
    }, arguments);

    var compileContent = function() {
        var content = [];
        var contentLength = 0;

        var appendContent = function(con, callback) {

            content.push(con);

            if (foundation.isKindOf(con, String)) {
                var buf = new Buffer(con)
                contentLength += buf.length;
                callback();

            } else if (foundation.isKindOf(con, Buffer)) {

                contentLength += con.length;
                callback();

            } else if (foundation.isKindOf(con, stream.Readable)) {

                fs.stat(con.path, function(err, stats) {

                    contentLength += stats.size
                    callback();
                })

            }
        }

        return async.all(Object.keys(options.data.body), function(name) {

            var handler = function(name, content) {
                return async(function() {
                    appendContent(innerBoundary + "\r\n", this.next);
                }).then(function() {
                    appendContent(`Content-Disposition: form-data; name="${name}"` + "\r\n\r\n", this.next);
                }).then(function() {
                    appendContent(content, this.next);
                }).then(function() {
                    appendContent("\r\n", this.next);
                })
            }

            var step = this;
            if (foundation.isKindOf(options.data.body[name], Array)) {

                async.all(options.data.body[name], function(value) {
                    handler(name, value).pipe(this);
                }).pipe(this);

            } else {

                handler(name, options.data.body[name]).pipe(this);

            }

        }).all(Object.keys(options.data.files), function(name) {

            var handler = function(name, file) {
                if (foundation.isKindOf(file.data, stream.Readable)) {
                    var filePath = file.data.path;
                    if (!file.filename) {
                        file.filename = path.basename(filePath);
                    }
                }

                if (!file.filename) {
                    step.reject("file must have a filename");
                }

                if (!file.contentType) {
                    file.contentType = mimes[path.extname(file.filename)] ? mimes[path.extname(file.filename)] : "text/plain";
                }

                var contentType = file.contentType;
                var filename = file.filename;
                return async(function() {
                    appendContent(innerBoundary + "\r\n", this.next);
                }).then(function() {
                    appendContent(`Content-Disposition: form-data; name="${name}"; filename="${filename}"` + "\r\n", this.next);
                }).then(function() {
                    appendContent(`Content-Type: ${contentType}` + "\r\n\r\n", this.next);
                }).then(function() {
                    appendContent(file.data, this.next);
                }).then(function() {
                    appendContent("\r\n", this.next);
                })

            }

            var step = this;
            if (foundation.isKindOf(options.data.files[name], Array)) {

                async.all(options.data.files[name], function(value) {
                    handler(name, value).pipe(this);
                }).pipe(this);

            } else {

                handler(name, options.data.files[name]).pipe(this);

            }

        }).then(function() {

            appendContent(innerBoundary + "--\r\n", this.next);

        }).then(function() {

            this.next(content, contentLength);

        }).rejected(function(err) {
            throw err;
        })

    }

    var uri = settings.uri;
    var options = settings.options;

    if (!uri) {
        throw new Error("URI not defined");
    }

    var requestURL = url.parse(uri);
    var requestModule = (requestURL.protocol == "https:") ? https : http;

    if (!options.headers["Host"]) {
        options.headers["Host"] = requestURL.host;
    }

    var boundary = "----HTTPClientFormBoundary" + Math.random().toString(32).substr(2);
    var innerBoundary = "--" + boundary;
    options.headers["Content-Type"] = "multipart/form-data; boundary=" + boundary;

    compileContent().then(function(content, contentLength) {

        options.headers["Content-Length"] = contentLength;

        var headersToSend = {};
        Object.keys(options.headers).forEach(function (key){
            if (options.headers[key]){
                headersToSend[key] = options.headers[key];
            }
        });

        var request = requestModule.request({
            "host": requestURL.hostname,
            "port": (requestURL.port ? requestURL.port : ((requestURL.protocol == "https:") ? 443 : 80)),
            "path": (requestURL.pathname ? requestURL.pathname : "/") + (requestURL.hash ? requestURL.hash : "") + (requestURL.query ? ("?" + requestURL.query) : ""),
            "method": "POST",
            "headers": headersToSend,
            "rejectUnauthorized": options.rejectUnauthorized || false
        });

        var aborted = false;
        var timedout = false;

        var timeoutHandle = async.delay(options.timeout, function () {

            if (!aborted) {

                aborted = true;
                timeout = true;

                request.abort();

                var error = new Error("Request timeout");

                error.causedByTimeout = true;

                options.onError(error);

            }

        });

        request.on("error", function (error) {

            if (!aborted) {

                timeoutHandle.cancel();

                if (foundation.isKindOf(error, Error)) {
                    options.onError(error);
                } else {
                    options.onError(new Error(error));
                }

            }

        });

        request.on("response", function (response) {

            timeoutHandle.cancel();

            if ([301, 302, 303, 307].indexOf(response.statusCode) >= 0) {

                var error = new Error("Response Error[" + response.statusCode + "]: " + http.STATUS_CODES[response.statusCode]);

                options.onError(err);

            } else {

                if (response.headers["set-cookie"]) {
                    for (var index in response.headers["set-cookie"]) {
                        try {

                            var cookie = response.headers["set-cookie"][index].split(";")[0];

                            this.setCookie(cookie.split("=")[0], cookie.split("=").slice(1).join("="));

                        } catch (error) {}
                    }
                }

                if (parseInt(response.statusCode) >= 400) {

                    var error = new Error("Response Error[" + response.statusCode + "]: " + (response.statusMessage || http.STATUS_CODES[response.statusCode]));

                    error.causedByTimeout = (response.statusCode === 504);

                    options.onError(error);

                } else {

                    var chunks = [];

                    options.onResponse(response);

                    response.on("data", function (chunk) {
                        chunks.push(chunk);
                    });

                    response.on("end", function () {

                        var rawBuffer = Buffer.concat(chunks);

                        var encoding = "identity";
                        if (response.headers["content-encoding"]) {
                            var encoding = response.headers["content-encoding"].split(/[ ,]/g).filter(function (encoding) {
                                return encoding && (encoding.length > 0);
                            })[0];
                        }

                        var compressDecoders = {
                            "gzip": function (buffer, callback) {
                                zlib.gunzip(buffer, callback);
                            },
                            "deflate": function (buffer, callback) {
                                zlib.inflate(buffer, callback);
                            }
                        };

                        var afterUncompressDecoder = function (error, buffer) {

                            if (error) {

                                request.emit("error", error);

                            } else {

                                switch (options.dataType) {

                                    case "json": {

                                        var content = buffer.toString(options.encoding);

                                        var invalidJSON = false;
                                        var object = null;
                                        try {
                                            object = JSON.parse(content);
                                        } catch (error) {

                                            invalidJSON = true;

                                            request.emit("error", error);

                                        }

                                        if (!invalidJSON) {
                                            options.onSuccess(JSON.parse(content), response);
                                        }

                                        break;
                                    }

                                    case "text": {

                                        var content = buffer.toString(options.encoding);

                                        options.onSuccess(content, response);

                                        break;
                                    }

                                    default: {

                                        options.onSuccess(buffer, response);

                                        break;
                                    }

                                }

                            }

                        };

                        if (compressDecoders[encoding]) {
                            compressDecoders[encoding](rawBuffer, afterUncompressDecoder);
                        } else {
                            afterUncompressDecoder(null, rawBuffer);
                        }

                    });
                }

            }

        }.bind(this));

        var msgLength = contentLength;
        async(function() {

            request.write("");

            msgLength += request._header.length;

            if (options.onProgress) {
                this.pool.lastSended = 0;
                this.pool.progressTimer = setInterval(function() {
                    var currentSended = request.socket._bytesDispatched;
                    options.onProgress({
                        "speed": (currentSended - this.pool.lastSended)*2,
                        "sendedData": currentSended,
                        "totalData": msgLength
                    })
                    this.pool.lastSended = currentSended;
                }.bind(this), 500);
            }

            this.next();

        }).all(content, function(con) {
            var step = this;
            var inputStream;
            if (foundation.isKindOf(con, stream.Readable)) {
                inputStream = con;
            } else {
                inputStream = mewStream.createReadable(con);
            }

            inputStream.pipe(request, {
                "end": false
            })

            inputStream.on('end', this.next);
        }).then(function() {
            request.end();

            if (this.pool.progressTimer) {
                options.onProgress({
                    "speed": (request.socket._bytesDispatched - this.pool.lastSended)*2,
                    "sendedData": request.socket._bytesDispatched,
                    "totalData": msgLength
                })
                clearInterval(this.pool.progressTimer);
            }
        })
    });
}

HTTPClient.prototype.download = function() {
    var httpClient = this;

    var settings = foundation.matchArguments([
        ["file"],
        ["file", "options"],
        ["uri", "file"],
        ["uri", "file", "options"],
        ["uri", "file", "options", "redirects"],
        ["uri", "file", "options", "redirects", "retried"]
    ], {
        "file": {
            "acceptTypes": "string"
        },
        "retried": {
            "acceptTypes": "number",
            "defaultValue": 0
        },
        "redirects": {
            "acceptTypes": "number",
            "defaultValue": 0
        },
        "uri": {
            "acceptTypes": "string",
            "defaultValue": this.uri
        },
        "options": {
            "acceptTypes": "object",
            "defaultValue": {},
            "mergeOptions": {

                "method": { "!valueType": "string", "!defaultValue": "GET" },

                "resumeBroken": { "!valueType": "boolean", "!defaultValue": true },

                "headers": {
                    "!defaultValue": {},
                    "Accept": { "!valueType": "string", "!defaultValue": "*/*" },
                    "User-Agent": { "!valueType": "string", "!defaultValue": "HTTP Client" },
                    "Accept-Encoding": { "!valueType": "string", "!defaultValue": "gzip, deflate" },
                    "Cookie": { "!valueType": "string", "!defaultValue": this.getCookies() }
                },

                "maxRetry": { "!valueType": "number", "!defaultValue": 5 },

                "encoding": { "!valueType": "string", "!defaultValue": "utf8" },

                "followRedirects": { "!valueType": "boolean", "!defaultValue": true },

                "maxRedirects": { "!valueType": "string", "!defaultValue": 10 },

                "deleteFileIfExists": { "!valueType": "boolean", "!defaultValue": true },

                "downloadTimeout": { "!valueType": "number", "!defaultValue": 30 },

                "timeout": { "!valueType": "number", "!defaultValue": 7500 },

                "onError": { "!valueType": "function", "!defaultValue": function (error) { throw error; } },

                "onSuccess": { "!valueType": "function", "!defaultValue": function () {} },

                "onResponse": { "!valueType": "function", "!defaultValue": function () {} },

                "onProgress": { "!valueType": "function", "!defaultValue": function() {} },

                "onRetry": { "!valueType": "function", "!defaultValue": function(r, cb) { cb(true) } }

            }
        }
    }, arguments);

    var uri = settings.uri;
    var file = settings.file;
    var options = settings.options;

    if (!uri) {
        throw new Error("URI not defined");
    }

    if (!file) {
        throw new Error("File path not defined");
    }

    if (fs.existsSync(file)) {
        if (settings.options.deleteFileIfExists) {
            storage.deleteFileSync(file);
        } else {
            settings.options.onError(new Error("File already exists"));
            return;
        }
    }

    var requestURL = url.parse(uri);
    var requestModule = (requestURL.protocol == "https:") ? https : http;

    if (!options.headers["Host"]) {
        options.headers["Host"] = requestURL.host;
    }

    if (!options.data) {

        options.headers["Content-Length"] = 0;

    } else if (foundation.isKindOf(options.data, String)) {

        options.data = new Buffer(options.data, options.encoding);

        options.headers["Content-Length"] = options.data.length;

    } else if (foundation.isKindOf(options.data, Buffer)) {

        options.headers["Content-Length"] = options.data.length;

    } else {

        options.data = new Buffer(queryStringify(options.data), options.encoding);

        options.headers["Content-Type"] = "application/x-www-form-urlencoded";
        options.headers["Content-Length"] = options.data.length;

    }

    var extName = ".mew.download.tmp";
    var eTagName = ".mew.download.etag";
    var existsSize = 0;

    if (options.resumeBroken && fs.existsSync(file + extName)) {
        var fileStat = fs.statSync(file + extName);

        options.headers["Range"] = "bytes=" + (fileStat.size - 1).toString();
        options.headers["If-Modified-Since"] = fileStat.mtime.toUTCString();
        existsSize = fileStat.size;

        if (fs.existsSync(file + eTagName)) {
            var eTag = fs.readFileSync(file + eTagName);
            options.headers["If-None-Match"] = eTag.toString();
        }

    }

    var aborted = false;
    var timedout = false;

    var timeoutHandle = async.delay(options.timeout, function () {

        if (!aborted) {

            aborted = true;
            timeout = true;

            request.abort();

            var error = new Error("Request timeout");

            error.causedByTimeout = true;

            options.onError(error);

        }

    });

    var headersToSend = {};
    Object.keys(options.headers).forEach(function (key){
        if (options.headers[key]){
            headersToSend[key] = options.headers[key];
        }
    });

    var request = requestModule.request({
        "host": requestURL.hostname,
        "port": (requestURL.port ? requestURL.port : ((requestURL.protocol == "https:") ? 443 : 80)),
        "path": (requestURL.pathname ? requestURL.pathname : "/") + (requestURL.hash ? requestURL.hash : "") + (requestURL.query ? ("?" + requestURL.query) : ""),
        "method": options.method,
        "headers": headersToSend,
        "rejectUnauthorized": options.rejectUnauthorized || false
    });

    request.on("error", function (error) {

        if (!aborted) {

            timeoutHandle.cancel();

            if (foundation.isKindOf(error, Error)) {
                options.onError(error);
            } else {
                options.onError(new Error(error));
            }

        }

    });

    var downloadProcess = {};

    var retry = function(reason) {
        if (downloadProcess.processTimer) {
            clearInterval(downloadProcess.processTimer);
        }

        if (settings.retried <= settings.options.maxRetry) {
            settings.options.onRetry(reason, function(needRetry) {
                if (needRetry) {
                    httpClient.download(settings.uri, settings.file, settings.options, 0, settings.retried + 1);
                }
            });
        } else {
            settings.options.onError(new Error("Too many retries"));
        }
    }

    var cleanAndRetry = function(reason) {
        storage.deleteFile(file + extName, function() {
            storage.deleteFile(file + eTagName, function() {
                storage.deleteFile(file, function() {
                    retry(reason);
                })
            })
        });
    }

    request.on("response", function (response) {

        timeoutHandle.cancel();

        if (([301, 302, 303, 307].indexOf(response.statusCode) >= 0) && options.followRedirects) {

            if (settings.redirects > options.maxRedirects) {

                var error = new Error("Too many redirects");

                error.causedByTimeout = false;

                options.onError(error);

            } else {

                var newURL = url.parse(url.resolve(requestURL.href, response.headers["location"]));

                if (response.statusCode === 303) {

                    options.method = "GET";

                    delete options.data;

                }

                request.removeAllListeners().on("error", function () {});
                if (!request.finished) {
                    request.abort();
                }

                this.download(newURL.href, options, settings.redirects + 1, settings.retried);

            }

        } else {

            if (response.headers["set-cookie"]) {
                for (var index in response.headers["set-cookie"]) {
                    try {

                        var cookie = response.headers["set-cookie"][index].split(";")[0];

                        this.setCookie(cookie.split("=")[0], cookie.split("=").slice(1).join("="));

                    } catch (error) {}
                }
            }

            if (parseInt(response.statusCode) >= 400) {

                var error = new Error("Response Error[" + response.statusCode + "]: " + (response.statusMessage || http.STATUS_CODES[response.statusCode]));

                error.causedByTimeout = (response.statusCode === 504);

                options.onError(error);

            } else {
                var contentLength = parseInt(response.headers["content-length"]);
                var finalFileSize = 0;

                if (response.headers["etag"]) {
                    fs.writeFile(file + eTagName, response.headers["etag"]);
                } else {
                    storage.deleteFile(file + eTagName);
                }

                var downloadFileStream = false;
                downloadProcess.downloaded = 0;
                downloadProcess.lastDownloaded = 0;
                downloadProcess.noSpeed = 0;

                if (response.statusCode == 206) {
                    downloadFileStream = fs.createWriteStream(file + extName, {
                        flags: 'a+'
                    });
                    finalFileSize = contentLength + existsSize;

                } else if (response.statusCode == 200) {
                    downloadFileStream = fs.createWriteStream(file + extName);
                    finalFileSize = contentLength;
                }

                response.on('data', function(data) {
                    downloadProcess.downloaded += data.length;
                })

                downloadProcess.processTimer = setInterval(function() {

                    if (downloadProcess.downloaded == downloadProcess.lastDownloaded) {
                        downloadProcess.noSpeed += 1;
                    }

                    if (settings.options.downloadTimeout && (downloadProcess.noSpeed > settings.options.downloadTimeout * 2)) {
                        clearInterval(downloadProcess.processTimer);
                        retry("Download Timeout");
                    } else {
                        settings.options.onProgress({
                            speed: (downloadProcess.downloaded - downloadProcess.lastDownloaded) * 2,
                            downloaded: downloadProcess.downloaded,
                            total: finalFileSize
                        })
                        downloadProcess.lastDownloaded = downloadProcess.downloaded;
                    }

                }, 500);

                if (downloadFileStream) {
                    response.pipe(downloadFileStream);
                } else {
                    settings.options.onError(new Error("Create write stream failed"));
                }

                response.on("end", function() {

                    var encodingWork = function() {
                        if (downloadProcess.processTimer) {
                            clearInterval(downloadProcess.processTimer);
                        }

                        settings.options.onProgress({
                            speed: (downloadProcess.downloaded - downloadProcess.lastDownloaded) * 2,
                            downloaded: downloadProcess.downloaded,
                            total: finalFileSize
                        })

                        var encoding = "identity";
                        if (response.headers["content-encoding"]) {
                            var encoding = response.headers["content-encoding"].split(/[ ,]/g).filter(function (encoding) {
                                return encoding && (encoding.length > 0);
                            })[0];
                        }



                        var compressDecoders = {
                            "gzip": zlib.createGunzip(),
                            "deflate": zlib.createInflateRaw()
                        };

                        if (encoding != "identity") {

                            var input = fs.createReadStream(file + extName);
                            var output = fs.createWriteStream(file);
                            input.pipe(compressDecoders[encoding]).pipe(output);

                        } else {
                            fs.renameSync(file + extName, file);
                        }

                        storage.deleteFile(file + extName, function() {
                            storage.deleteFile(file + eTagName, function() {
                                settings.options.onSuccess();
                            })
                        });
                    }

                    downloadFileStream.on('close', function() {

                        fs.stat(file + extName, function(err, stat) {
                            if (err) {
                                settings.options.onError(err);
                            } else {
                                if (finalFileSize) {

                                    if (stat.size < finalFileSize) {

                                        retry("Downloaded file is smaller than expected");

                                    } else if (stat.size > finalFileSize) {

                                        cleanAndRetry("Downloaded file is larger than expected");

                                    } else {

                                        encodingWork();

                                    }
                                } else {

                                    encodingWork();

                                }
                            }
                        })
                    })

                })

            }

        }

    }.bind(this));

    if (options.data) {
        request.write(options.data);
    }

    request.end();

}

HTTPClient.prototype.request = function () {
    var settings = foundation.matchArguments([
        [],
        ["redirects"],
        ["options"],
        ["options", "redirects"],
        ["uri", "options"],
        ["uri", "options", "redirects"]
    ], {
        "redirects": {
            "acceptTypes": "number",
            "defaultValue": 0
        },
        "uri": {
            "acceptTypes": "string",
            "defaultValue": this.uri
        },
        "options": {
            "acceptTypes": "object",
            "defaultValue": {},
            "mergeOptions": {

                "maxRedirects": { "!valueType": "string", "!defaultValue": 10 },

                "method": { "!valueType": "string", "!defaultValue": "GET" },

                "headers": {
                    "!defaultValue": {},
                    "Accept": { "!valueType": "string", "!defaultValue": "*/*" },
                    "User-Agent": { "!valueType": "string", "!defaultValue": "HTTP Client" },
                    "Accept-Encoding": { "!valueType": "string", "!defaultValue": "gzip, deflate" },
                    "Cookie": { "!valueType": "string", "!defaultValue": this.getCookies() }
                },

                "encoding": { "!valueType": "string", "!defaultValue": "utf8" },

                "followRedirects": { "!valueType": "boolean", "!defaultValue": true },

                "dataType": { "!valueType": "string", "!defaultValue": "json" },

                "timeout": { "!valueType": "number", "!defaultValue": 7500 },

                "onError": { "!valueType": "function", "!defaultValue": function (error) { throw error; } },

                "onSuccess": { "!valueType": "function", "!defaultValue": function () {} },

                "onResponse": { "!valueType": "function", "!defaultValue": function () {} }

            }
        }
    }, arguments);

    var uri = settings.uri;
    var options = settings.options;

    if (!uri) {
        throw new Error("URI not defined");
    }

    var requestURL = url.parse(uri);
    var requestModule = (requestURL.protocol == "https:") ? https : http;

    if (!options.headers["Host"]) {
        options.headers["Host"] = requestURL.host;
    }

    if (!options.data) {

        options.headers["Content-Length"] = 0;

    } else if (foundation.isKindOf(options.data, String)) {

        options.data = new Buffer(options.data, options.encoding);

        options.headers["Content-Length"] = options.data.length;

    } else if (foundation.isKindOf(options.data, Buffer)) {

        options.headers["Content-Length"] = options.data.length;

    } else {

        options.data = new Buffer(queryStringify(options.data), options.encoding);

        options.headers["Content-Type"] = "application/x-www-form-urlencoded";
        options.headers["Content-Length"] = options.data.length;

    }

    var aborted = false;
    var timedout = false;

    var timeoutHandle = async.delay(options.timeout, function () {

        if (!aborted) {

            aborted = true;
            timeout = true;

            request.abort();

            var error = new Error("Request timeout");

            error.causedByTimeout = true;

            options.onError(error);

        }

    });

    var headersToSend = {};
    Object.keys(options.headers).forEach(function (key){
        if (options.headers[key]){
            headersToSend[key] = options.headers[key];
        }
    });

    var request = requestModule.request({
        "host": requestURL.hostname,
        "port": (requestURL.port ? requestURL.port : ((requestURL.protocol == "https:") ? 443 : 80)),
        "path": (requestURL.pathname ? requestURL.pathname : "/") + (requestURL.hash ? requestURL.hash : "") + (requestURL.query ? ("?" + requestURL.query) : ""),
        "method": options.method,
        "headers": headersToSend,
        "rejectUnauthorized": options.rejectUnauthorized || false
    });

    request.on("error", function (error) {

        if (!aborted) {

            timeoutHandle.cancel();

            if (foundation.isKindOf(error, Error)) {
                options.onError(error);
            } else {
                options.onError(new Error(error));
            }

        }

    });

    request.on("response", function (response) {

        timeoutHandle.cancel();

        if (([301, 302, 303, 307].indexOf(response.statusCode) >= 0) && options.followRedirects) {

            if (settings.redirects > options.maxRedirects) {

                var error = new Error("Too many redirects");

                error.causedByTimeout = false;

                options.onError(error);

            } else {

                var newURL = url.parse(url.resolve(requestURL.href, response.headers["location"]));

                if (response.statusCode === 303) {

                    options.method = "GET";

                    delete options.data;

                }

                request.removeAllListeners().on("error", function () {});
                if (!request.finished) {
                    request.abort();
                }

                this.request(newURL.href, options, settings.redirects + 1);

            }

        } else {

            if (response.headers["set-cookie"]) {
                for (var index in response.headers["set-cookie"]) {
                    try {

                        var cookie = response.headers["set-cookie"][index].split(";")[0];

                        this.setCookie(cookie.split("=")[0], cookie.split("=").slice(1).join("="));

                    } catch (error) {}
                }
            }

            if (parseInt(response.statusCode) >= 400) {

                var error = new Error("Response Error[" + response.statusCode + "]: " + (response.statusMessage || http.STATUS_CODES[response.statusCode]));

                error.causedByTimeout = (response.statusCode === 504);

                options.onError(error);

            } else {

                var chunks = [];

                options.onResponse(response);

                response.on("data", function (chunk) {
                    chunks.push(chunk);
                });

                response.on("end", function () {

                    var rawBuffer = Buffer.concat(chunks);

                    var encoding = "identity";
                    if (response.headers["content-encoding"]) {
                        var encoding = response.headers["content-encoding"].split(/[ ,]/g).filter(function (encoding) {
                            return encoding && (encoding.length > 0);
                        })[0];
                    }

                    var compressDecoders = {
                        "gzip": function (buffer, callback) {
                            zlib.gunzip(buffer, callback);
                        },
                        "deflate": function (buffer, callback) {
                            zlib.inflate(buffer, callback);
                        }
                    };

                    var afterUncompressDecoder = function (error, buffer) {

                        if (error) {

                            request.emit("error", error);

                        } else {

                            switch (options.dataType) {

                                case "json": {

                                    var content = buffer.toString(options.encoding);

                                    var invalidJSON = false;
                                    var object = null;
                                    try {
                                        object = JSON.parse(content);
                                    } catch (error) {

                                        invalidJSON = true;

                                        request.emit("error", error);

                                    }

                                    if (!invalidJSON) {
                                        options.onSuccess(JSON.parse(content), response);
                                    }

                                    break;
                                }

                                case "text": {

                                    var content = buffer.toString(options.encoding);

                                    options.onSuccess(content, response);

                                    break;
                                }

                                default: {

                                    options.onSuccess(buffer, response);

                                    break;
                                }

                            }

                        }

                    };

                    if (compressDecoders[encoding]) {
                        compressDecoders[encoding](rawBuffer, afterUncompressDecoder);
                    } else {
                        afterUncompressDecoder(null, rawBuffer);
                    }

                });
            }

        }

    }.bind(this));

    if (options.data) {
        request.write(options.data);
    }

    request.end();

};

HTTPClient.prototype.getCookies = function () {

    return Object.keys(this.cookies).map((function (key) {
        return key + "=" + this.cookies[key] + ";"
    }).bind(this)).join("");

};

HTTPClient.prototype.setCookie = function(key, value) {
    this.cookies[key] = value;
};

module.exports = HTTPClient;
