// HTTP client
//
var http = require("http");
var https = require("https");
var url = require("url");
var zlib = require('zlib');

var foundation = require("./foundation.js");
var async = require("./async.js");

var queryStringify = function (object) {

    return foundation.keys(object).map(function (key) {

        var data = "";

        if ((object[key] !== null) && (object[key] !== undefined)) {

            switch (object[key].constructor) {

                case Boolean: { data = object[key] ? "true" : "false"; break; }
                case Number: { data = object[key] + ""; break; }
                case String: { data = object[key]; break; }

                default: { data = JSON.stringify(object[key]); break; }

            }

        }

        return key + "=" + encodeURIComponent(data);

    }).join("&");

};

var HTTPClient = function HTTPClient(uri, options) {

    this.uri = uri;

    this.accumulatedErrors = 0;

    this.cookies = foundation.advancedMerge({
        "!valueType": "object",
        "!defaultValue": {}
    }, (options ? options.cookies : null));

    if (options) {
        delete options.cookies;
    }

    this.options = foundation.advancedMerge({
        "errorTimeouts": {
            "!valueType": "array",
            "!defaultValue": [0, 100, 200, 400, 800, 1600, 3200]
        }
    }, options);

};

HTTPClient.prototype.jsonrpc = function () {

    var settings = foundation.matchArguments([
        ["method", "callback"],
        ["method", "callback", "options"],
        ["method", "parameters", "callback"],
        ["method", "parameters", "callback", "options"],
    ], {
        "method": "string",
        "parameters": "array-like",
        "callback": "function",
        "options": "any"
    }, arguments);

    var data = {
        "query": JSON.stringify({
            "jsonrpc": "2.0",
            "method": settings.method,
            "params": settings.parameters ? settings.parameters : [],
            "id": new Date().getTime()
        })
    };

    if (settings.options && settings.options.file && /^data:(text|image)\/([a-zA-Z]+);base64,([A-Za-z0-9\+\/=]*)$/.test(settings.options.file)) {
        data.file = settings.options.file;
        data.fileName = settings.options.fileName;
    }

    return this.request(this.uri, {
        "data": data,
        "method": "POST",
        "onError": function (error) {
            if (settings.callback) {
                settings.callback(error);
            }
        },
        "onSuccess": function (response) {
            if (settings.callback) {
                settings.callback(response.error, response.result);
            }
        }
    });

};

HTTPClient.prototype.request = function () {

    var settings = foundation.matchArguments([
        [],
        ["options"],
        ["uri", "options"]
    ], {
        "uri": {
            "acceptTypes": "string",
            "defaultValue": this.uri
        },
        "options": {
            "acceptTypes": "object",
            "defaultValue": {},
            "mergeOptions": {

                "method": { "!valueType": "string", "!defaultValue": "GET" },

                "headers": {
                    "!defaultValue": {},
                    "Accept": { "!valueType": "string", "!defaultValue": "*/*" },
                    "User-Agent": { "!valueType": "string", "!defaultValue": "HTTP Client" },
                    "Accept-Encoding": { "!valueType": "string", "!defaultValue": "gzip, deflate" },
                    "Cookie": { "!valueType": "string", "!defaultValue": this.getCookies() }
                },

                "encoding": { "!valueType": "string", "!defaultValue": "utf8" },

                "followRedirects": { "!valueType": "boolean", "!defaultValue": true },

                "dataType": { "!valueType": "string", "!defaultValue": "json" },

                "timeout": { "!valueType": "number", "!defaultValue": 7500 },

                "onError": { "!valueType": "function", "!defaultValue": function (error) { throw error; } },

                "onSuccess": { "!valueType": "function", "!defaultValue": function () {} },

                "onResponse": { "!valueType": "function", "!defaultValue": function () {} }

            }
        }
    }, arguments);

    var uri = settings.uri;
    var options = settings.options;

    if (!uri) {
        throw new Error("URI not defined");
    }

    var requestURL = url.parse(uri);
    var requestModule = (requestURL.protocol == "https:") ? https : http;

    if (!options.headers["Host"]) {
        options.headers["Host"] = requestURL.host;
    }

    if (!options.data) {

        options.headers["Content-Length"] = 0;

    } else if (foundation.isKindOf(options.data, String)) {

        options.data = new Buffer(options.data, options.encoding);

        options.headers["Content-Length"] = options.data.length;

    } else if (foundation.isKindOf(options.data, Buffer)) {

        options.headers["Content-Length"] = options.data.length;

    } else {

        options.data = new Buffer(queryStringify(options.data), options.encoding);

        options.headers["Content-Type"] = "application/x-www-form-urlencoded";
        options.headers["Content-Length"] = options.data.length;

    }

    var aborted = false;
    var timedout = false;

    var timeoutHandle = async.delay(options.timeout, function () {

        if (!aborted) {

            aborted = true;
            timeout = true;

            request.abort();

            var error = new Error("Request timeout");

            error.causedByTimeout = true;

            options.onError(error);

        }

    });

    var headersToSend = {};
    Object.keys(options.headers).forEach(function(key){
        if (options.headers[key]){
            headersToSend[key] = options.headers[key];
        }
    });

    var request = requestModule.request({
        "host": requestURL.hostname,
        "port": (requestURL.port ? requestURL.port : ((requestURL.protocol == "https:") ? 443 : 80)),
        "path": (requestURL.pathname ? requestURL.pathname : "/") + (requestURL.hash ? requestURL.hash : "") + (requestURL.query ? ("?" + requestURL.query) : ""),
        "method": options.method,
        "headers": headersToSend,
        "rejectUnauthorized": options.rejectUnauthorized || false
    });

    request.on("error", function (error) {

        if (!aborted) {

            timeoutHandle.cancel();

            if (foundation.isKindOf(error, Error)) {
                options.onError(error);
            } else {
                options.onError(new Error(error));
            }

        }

    });

    request.on("response", function (response) {

        timeoutHandle.cancel();

        if (([301, 302, 303, 307].indexOf(response.statusCode) >= 0) && options.followRedirects) {

            var newURL = url.parse(url.resolve(requestURL.href, response.headers["location"]));

            if (response.statusCode === 303) {

                options.method = "GET";

                delete options.data;

            }

            request.removeAllListeners().on("error", function () {});
            if (!request.finished) {
                request.abort();
            }

            this.request(newURL.href, options);

        } else {

            if (response.headers["set-cookie"]) {
                for (var index in response.headers["set-cookie"]) {
                    try {

                        var cookie = response.headers["set-cookie"][index].split(";")[0];

                        this.setCookie(cookie.split("=")[0], cookie.split("=").slice(1).join("="));

                    } catch (error) {}
                }
            }

            if (parseInt(response.statusCode) >= 400) {

                var error = new Error("Response Error[" + response.statusCode + "]: " + http.STATUS_CODES[response.statusCode]);

                error.causedByTimeout = (response.statusCode === 504);

                options.onError(error);

            } else {

                var chunks = [];

                options.onResponse(response);

                response.on("data", function (chunk) {
                    chunks.push(chunk);
                });

                response.on("end", function () {

                    var rawBuffer = Buffer.concat(chunks);

                    var encoding = "identity";
                    if (response.headers["content-encoding"]) {
                        var encoding = response.headers["content-encoding"].split(/[ ,]/g).filter(function (encoding) {
                            return encoding && (encoding.length > 0);
                        })[0];
                    }

                    var compressDecoders = {
                        "gzip": function (buffer, callback) {
                            zlib.gunzip(buffer, callback);
                        },
                        "deflate": function (buffer, callback) {
                            zlib.inflate(buffer, callback);
                        }
                    };

                    var afterUncompressDecoder = function (error, buffer) {

                        if (error) {

                            request.emit("error", error);

                        } else {

                            switch (options.dataType) {

                                case "json": {

                                    var content = buffer.toString(options.encoding);

                                    var invalidJSON = false;
                                    var object = null;
                                    try {
                                        object = JSON.parse(content);
                                    } catch (error) {

                                        invalidJSON = true;

                                        request.emit("error", error);

                                    }

                                    if (!invalidJSON) {
                                        options.onSuccess(JSON.parse(content), response);
                                    }

                                    break;
                                }

                                case "text": {

                                    var content = buffer.toString(options.encoding);

                                    options.onSuccess(content, response);

                                    break;
                                }

                                default: {

                                    options.onSuccess(buffer, response);

                                    break;
                                }

                            }

                        }

                    };

                    if (compressDecoders[encoding]) {
                        compressDecoders[encoding](rawBuffer, afterUncompressDecoder);
                    } else {
                        afterUncompressDecoder(null, rawBuffer);
                    }

                });
            }

        }

    }.bind(this));

    if (options.data) {
        request.write(options.data);
    }

    request.end();

};

HTTPClient.prototype.getCookies = function () {

    return Object.keys(this.cookies).map((function (key) {
        return key + "=" + this.cookies[key] + ";"
    }).bind(this)).join("");

};

HTTPClient.prototype.setCookie = function(key, value) {
    this.cookies[key] = value;
};

module.exports = HTTPClient;
