var stream = require("stream");
var util = require("util");

var foundation = require("./foundation.js");

var listenerSymbol = Symbol("listener");

var createReadable = function (buffer) {

    if (foundation.isKindOf(buffer, String)) {
        buffer = new Buffer(buffer, "utf8");
    }

    var readable = new stream.Readable();

    readable._read = function () {};

    readable.push(buffer);

    readable.push(null);

    return readable;

};

var getAllRestBuffer = function (readable, callback) {
    
    if (readable.closed) {

        callback(null, new Buffer(0));

    } else {

        var allData = [];

        var failed = false;

        readable.on("data", function (data) {
            if (!failed) {
                allData.push(data);
            }
        });

        readable.on("error", function (error) {
            if (!failed) {
                failed = true;
                callback(error);
            }
        });

        readable.on("end", function () {
            if (!failed) {
                if ((readable._readableState.encoding) && 
                    (readable._readableState.encoding !== "binary")) {
                    callback(null, allData.join(""));
                } else {
                    callback(null, Buffer.concat(allData));
                }
            }
        });

    }

};

var pipeBetweenReadables = function (inputReadable, outputReadable, callback) {

    if (inputReadable.closed) {

        if (callback instanceof Function) {
            callback();
        } else if (callback) {
            outputReadable.push(null);
        }

    } else {

        var failed = false;
        var ended = false;

        outputReadable._read = (function (read) {
            return function (size) {
                if ((!ended) && (!failed)) {
                    inputReadable.resume();
                } else if (read) {
                    read.apply(this, arguments);
                }
            };
        })(outputReadable._read);

        inputReadable.on("end", function () {
            if (!failed) {
                if (callback instanceof Function) {
                    callback();
                } else if (callback) {
                    outputReadable.push(null);
                }
            }
        });

        inputReadable.on("data", function (data) {
            if (!failed) {
                if (!outputReadable.push(data)) {
                    inputReadable.pause();
                }
            }
        });

        inputReadable.on("error", function (error) {

            if (!failed) {

                failed = true;

                outputReadable.emit("error", error);

                if (callback instanceof Function) {
                    callback(error);
                }

            }

        });

    }

};

var ListenedTransform = function (listener) {

    stream.Transform.call(this);

    this[listenerSymbol] = listener;

};

util.inherits(ListenedTransform, stream.Transform);

ListenedTransform.prototype._transform = function(chunk, encoding, callback) {

    this[listenerSymbol](chunk);

    this.push(chunk);

    callback();

};

ListenedTransform.prototype._flush = function (callback) {

    this[listenerSymbol]();

    callback();

};

var pipeWithListener = function (readable, listener) {
    return readable.pipe(new ListenedTransform(listener), {
        "end": true
    });
};


var pipeWithLengthListener = function (readable, listener) {

    var length = 0;

    return pipeWithListener(readable, function (data) {

        if (data) {
            length += data.length;
        } else {
            listener(length);
        }

    });
};

module.exports = {
    "createReadable": createReadable,
    "getAllRestBuffer": getAllRestBuffer,
    "pipeBetweenReadables": pipeBetweenReadables,
    "pipeWithListener": pipeWithListener,
    "pipeWithLengthListener": pipeWithLengthListener
};