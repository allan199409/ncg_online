var util = require("util");

var comparator = require("./comparator.js");
var foundation = require("./foundation.js");
var home = require("./home.js");
var storage = require("./storage.js");

var levels = ["file", "module", "function", "block", "*"];

var functions = {};

var annotations = {};

var annotationFunctions = {};

var generateAnnotationFunction = function (path) {

    if (!annotationFunctions.hasOwnProperty(path)) {

        var target = function () {};

        var fields = {};

        var annotationFunction = new Proxy(target, {

            "get": function (target, property, receiver) {

                if (fields.hasOwnProperty(property)) {
                    return fields[property];
                } else {
                    return generateAnnotationFunction(path + "." + property);
                }

            },

            "set": function (target, property, value, receiver) {

                fields[property] = value;

                return value;
            },

            "apply": function (target, that, functionArguments) {

                var scope = generateAnnotationScope();

                var restNamespaces = {};

                var namespaces = {
                    "js.namespace": true,
                    "js.common": true,
                    "js.meta": true,
                    "js.level": true,
                    "js.function": true
                };

                Object.keys(annotations).forEach(function (namespace) {
                    if (!namespaces.hasOwnProperty(namespace)) {
                        restNamespaces[namespace] = true;
                    }
                });

                if (locals[scope.file].namespaces) {
                    Object.keys(locals[scope.file].namespaces).sort(comparator.numberComparator).forEach(function (line) {
                        Object.keys(locals[scope.file].namespaces[line]).sort(comparator.numberComparator).forEach(function (column) {

                            var record = locals[scope.file].namespaces[line][column];

                            if (record.action === "import") {

                                Object.keys(restNamespaces).slice(0).forEach(function (namespace) {
                                    if (record.regex.test(namespace)) {
                                        delete restNamespaces[namespace];
                                        namespaces[namespace] = true;
                                    }
                                });

                            } else if (record.action === "forget") {

                                Object.keys(namespaces).slice(0).forEach(function (namespace) {
                                    if (record.regex.test(namespace)) {
                                        restNamespaces[namespace] = true;
                                        delete namespaces[namespace];
                                    }
                                });

                            } else {
                                throw new Error("Invalid namespace record action");
                            }

                        });
                    });
                }

                var results = [];

                Object.keys(annotations).filter(function (namespace) {
                    return ((namespaces.hasOwnProperty(namespace) && namespaces[namespace]) &&
                            (annotations[namespace] && annotations[namespace][path] &&
                             (annotations[namespace][path].length > 0)));
                }).forEach(function (namespace) {
                    annotations[namespace][path].forEach(function (processor) {
                        results.push(processor.apply(scope, functionArguments));
                    });
                });

                if (results.length > 0) {
                    return foundation.merge.apply(foundation, results);
                } else {
                    throw new Error("Annotation not exist");
                }

            }

        });

        annotationFunctions[path] = annotationFunction;

    }

    return annotationFunctions[path];

};

var registerAnnotation = function (namespace, path, processor, allowCombination) {

    if (path.indexOf("@") !== -1) {
        throw new Error("Invalid path for annotation registration");
    }

    if (!annotations.hasOwnProperty(namespace)) {
        annotations[namespace] = {};
    }

    if (!annotations[namespace].hasOwnProperty(path)) {
        annotations[namespace][path] = [];
    }

    if ((annotations[namespace][path].length === 0) || allowCombination) {
        annotations[namespace][path].push(processor);
    } else {
        throw new Error("Duplicated annotation found");
    }

    var prefix = path.split(".")[0];
    if (!global.hasOwnProperty("@" + prefix)) {
        global["@" + prefix] = generateAnnotationFunction(prefix);
    }

};

var locals = {
    "!global": {}
};


// ->
// -> offset
// -> file
// -> file, line
// -> file, line, column
//
var generateAnnotationScope = function () {

    var fileLine = null;

    var offset = 2;
    if (arguments.length > 0) {

        if (foundation.isKindOf(arguments[0], Number)) {
            fileLine = home.getFileLine(offset + arguments[0], 0, true).split(":");
        } else {

            var lineNumber = parseInt(arguments[1]);
            if (!isFinite(lineNumber)) {
                lineNumber = 0;
            }

            var columnNumber = parseInt(arguments[2]);
            if (!isFinite(columnNumber)) {
                columnNumber = 0;
            }

            fileLine = [arguments[0], lineNumber + "", columnNumber + ""];
        }

    } else {
        fileLine = home.getFileLine(offset, 0, true).split(":");
    }

    var file = storage.standardizePath(fileLine.slice(0, fileLine.length - 2).join(":"));
    var line = parseInt(fileLine[fileLine.length - 2]);
    var column = parseInt(fileLine[fileLine.length - 1]);

    if (!locals[file]) {
        locals[file] = {};
    }

    var scope = {
        "caller": arguments.callee.caller.caller,
        "file": file,
        "line": line,
        "column": column,
        "local": locals[file],
        "global": locals["!global"],
        "get": function (level, name) {

            var levelIndex = 0;

            // Initialize all annotations for file
            // TODO: Cache it
            //
            var allAnnotations = {};

            levelIndex = 0;
            while (levelIndex < levels.length) {

                allAnnotations[levels[levelIndex]] = [];
                allAnnotations[levels[levelIndex] + "@milestone"] = [];

                if (locals[scope.file] && locals[scope.file].levels && locals[scope.file].levels[levels[levelIndex]]) {

                    var lineData = locals[scope.file].levels[levels[levelIndex]];

                    if (!lineData.milestones) {
                        lineData.milestones = Object.keys(lineData.milestoneSet).map(function (key) {
                            return parseInt(key);
                        }).sort(comparator.numberComparator);
                    }

                    if (!lineData.lines) {
                        lineData.lines = Object.keys(lineData.lineSet).map(function (key) {
                            return parseInt(key);
                        }).sort(comparator.numberComparator);
                    }

                    var lineIndex = 0;
                    while (lineIndex < lineData.lines.length) {

                        var columnData = lineData[lineData.lines[lineIndex]];
                        if (columnData) {

                            if (!columnData.milestones) {
                                columnData.milestones = Object.keys(columnData.milestoneSet).map(function (key) {
                                    return parseInt(key);
                                }).sort(comparator.numberComparator);
                            }

                            if (!columnData.columns) {
                                columnData.columns = Object.keys(columnData.columnSet).map(function (key) {
                                    return parseInt(key);
                                }).sort(comparator.numberComparator);
                            }

                            columnData.columns.forEach(function (column) {

                                allAnnotations[levels[levelIndex]].push({
                                    "line": lineData.lines[lineIndex],
                                    "column": parseInt(column),
                                    "annotation": columnData[column],
                                    "milestone": columnData.milestoneSet.hasOwnProperty(column)
                                });

                                if (columnData.milestoneSet[column]) {
                                    allAnnotations[levels[levelIndex] + "@milestone"].push({
                                        "line": lineData.lines[lineIndex],
                                        "column": parseInt(column)
                                    });
                                }

                            });

                        }

                        ++lineIndex;
                    }

                }

                ++levelIndex;
            }

            // Identify annotation ranges
            //
            var annotations = {};

            levelIndex = 0;
            while (levelIndex < levels.length) {

                annotations[levels[levelIndex]] = {};

                var levelData = allAnnotations[levels[levelIndex]];
                var levelMilestoneData = allAnnotations[levels[levelIndex] + "@milestone"];

                if (levels[levelIndex] !== "*") {

                    if (levelIndex > 0) {

                        var startIndex = maxLessThanOrEqualTo(levelMilestoneData, 0, levelMilestoneData.length, scope, recordLessThanOrEqualComparator);

                        if (startIndex !== null) {
                            annotations[levels[levelIndex]].start = {
                                "line": levelMilestoneData[startIndex].line,
                                "column": levelMilestoneData[startIndex].column
                            };
                        } else {
                            annotations[levels[levelIndex]].start = {
                                "line": Infinity,
                                "column": Infinity
                            };
                        }

                        var endIndex = minGreaterThanOrEqualTo(levelMilestoneData, 0, levelMilestoneData.length, {
                            "line": annotations[levels[levelIndex - 1]].start.line,
                            "column": annotations[levels[levelIndex - 1]].start.column
                        }, recordGreaterThanOrEqualComparator);
                        if (endIndex !== null) {
                            annotations[levels[levelIndex - 1]].end = {
                                "line": levelMilestoneData[endIndex].line,
                                "column": levelMilestoneData[endIndex].column
                            };
                        } else {
                            annotations[levels[levelIndex - 1]].end = {
                                "line": annotations[levels[levelIndex]].start.line,
                                "column": annotations[levels[levelIndex]].start.column
                            };
                        }

                        if (levels[levelIndex + 1] === "*") {

                            var endIndex = minGreaterThanOrEqualTo(levelMilestoneData, 0, levelMilestoneData.length, {
                                "line": annotations[levels[levelIndex]].start.line,
                                "column": annotations[levels[levelIndex]].start.column + 1
                            }, recordGreaterThanOrEqualComparator);
                            if (endIndex !== null) {
                                annotations[levels[levelIndex]].end = {
                                    "line": levelMilestoneData[endIndex].line,
                                    "column": levelMilestoneData[endIndex].column
                                };
                            } else {
                                annotations[levels[levelIndex]].end = {
                                    "line": annotations[levels[levelIndex]].start.line,
                                    "column": annotations[levels[levelIndex]].start.column
                                };
                            }

                        }

                    } else {
                        annotations[levels[levelIndex]].start = {
                            "line": 0,
                            "column": 0
                        };
                    }

                }

                ++levelIndex;
            }

            // Filter annotations in ranges
            //
            levelIndex = 0;
            while (levelIndex < levels.length) {

                if (levels[levelIndex] != "*") {

                    annotations[levels[levelIndex]].records = [];

                    var startIndex = minGreaterThanOrEqualTo(allAnnotations[levels[levelIndex]], 0, allAnnotations[levels[levelIndex]].length, annotations[levels[levelIndex]].start, recordGreaterThanOrEqualComparator);
                    if (startIndex !== null) {

                        var endIndex = minGreaterThanOrEqualTo(allAnnotations[levels[levelIndex]], 0, allAnnotations[levels[levelIndex]].length, annotations[levels[levelIndex]].end, recordGreaterThanOrEqualComparator);
                        if (endIndex === null) {
                            endIndex = allAnnotations[levels[levelIndex]].length;
                        }

                        annotations[levels[levelIndex]].records = allAnnotations[levels[levelIndex]].slice(startIndex, endIndex);

                    }

                    startIndex = minGreaterThanOrEqualTo(allAnnotations["*"], 0, allAnnotations["*"].length, annotations[levels[levelIndex]].start, recordGreaterThanOrEqualComparator);
                    if (startIndex !== null) {

                        var endIndex = minGreaterThanOrEqualTo(allAnnotations["*"], 0, allAnnotations["*"].length, annotations[levels[levelIndex]].end, recordGreaterThanOrEqualComparator);
                        if (endIndex === null) {
                            endIndex = allAnnotations["*"].length;
                        }

                        allAnnotations["*"].slice(startIndex, endIndex).forEach(function (record) {
                            annotations[levels[levelIndex]].records.push(record);
                        });

                    }

                    annotations[levels[levelIndex]].records.sort(recordComparator);

                }

                ++levelIndex;
            }

            // Summary annotation data
            // TODO: Cache it
            //
            var data = {};

            levelIndex = 0;
            while (levelIndex < levels.length) {

                if (levels[levelIndex] !== "*") {
                    data[levels[levelIndex]] = foundation.merge.apply(foundation, annotations[levels[levelIndex]].records.map(function (settings) {
                        return settings.annotation;
                    }));
                }

                ++levelIndex;
            }

            // Bind mew js info into file
            //
            var mewJSInfo = home.getMewJSInfo(file);
            if (mewJSInfo) {
                data.file = foundation.merge(data.file, mewJSInfo);
            }

            // Filter data according to requirements
            //
            if (level) {

                data = data[level];

                if (name && (!foundation.isNull(data))) {
                    data = data[name];
                }

            }

            return data;
        },
        "put": function (level) {

            var options = {};
            if (arguments.length > 2) {
                options[arguments[1]] = arguments[2];
            } else {
                options = arguments[1];
            }

            if (!locals[file].levels) {
                locals[file].levels = {};
            }
            if (!locals[file].levels[level]) {
                locals[file].levels[level] = { "lineSet": {}, "lines": [], "milestoneSet": {}, "milestones": [] };
            }

            if (!locals[file].levels[level][line]) {
                if (options && options.hasOwnProperty("name") && (level !== "*")) {
                    delete locals[file].levels[level].milestones;
                    locals[file].levels[level].milestoneSet[line] = true;
                }
                delete locals[file].levels[level].lines;
                locals[file].levels[level].lineSet[line] = true;
                locals[file].levels[level][line] = { "columnSet": {}, "columns": [], "milestoneSet": {}, "milestones": [] };
            }

            if (!locals[file].levels[level][line][column]) {
                if (options && options.hasOwnProperty("name") && (level !== "*")) {
                    delete locals[file].levels[level][line].milestones;
                    locals[file].levels[level][line].milestoneSet[column] = true;
                }
                delete locals[file].levels[level][line].columns;
                locals[file].levels[level][line].columnSet[column] = true;
                locals[file].levels[level][line][column] = {};
            }

            locals[file].levels[level][line][column] = foundation.merge(locals[file].levels[level][line][column], options);

        }
    };

    return scope;

};

var maxLessThanOrEqualTo = function (list, offset, length, number, comparator) {

    if (!comparator) {
        comparator = function (a, b) {
            return a <= b;
        };
    }

    switch (length) {

        case 0: { return null; }

        case 1: { return comparator(list[offset], number) ? offset : null; }

        default: {

            var half = length >> 1;

            if (comparator(list[offset + half], number)) {
                return maxLessThanOrEqualTo(list, offset + half, length - half, number, comparator);
            } else {
                return maxLessThanOrEqualTo(list, offset, half, number, comparator);
            }

        }

    }

};

var minGreaterThanOrEqualTo = function (list, offset, length, number, comparator) {

    if (!comparator) {
        comparator = function (a, b) {
            return a >= b;
        };
    }

    switch (length) {

        case 0: { return null; }

        case 1: { return comparator(list[offset], number) ? offset : null; }

        default: {

            var half = (length >> 1) - 1;

            if (comparator(list[offset + half], number)) {
                return minGreaterThanOrEqualTo(list, offset, half + 1, number, comparator);
            } else {
                return minGreaterThanOrEqualTo(list, offset + half + 1, length - half - 1, number, comparator);
            }

        }

    }

};

var recordComparator = function (a, b) {

    if (a.line < b.line) {
        return -1;
    } else if (a.line > b.line) {
        return 1;
    } else {
        if (a.column < b.column) {
            return -1;
        } else if (a.column > b.column) {
            return 1;
        } else {
            return 0;
        }
    }

};

var recordGreaterThanOrEqualComparator = function (a, b) {
    return recordComparator(a, b) >= 0;
};

var recordLessThanOrEqualComparator = function (a, b) {
    return recordComparator(a, b) <= 0;
};

var analyzeError = function (error) {

    var stack = foundation.getStack(error).split("\n");

    var name = null;
    var file = null;
    var line = null;
    var column = null;

    var report = null;

    var looper = 0;
    while ((looper < stack.length) && ((!file) || (!storage.isRootPath(file)))) {

        var stackLine = stack[looper];

        var components = stackLine.slice(7, -1).split("(");

        name = components[0].trim();

        components = components.slice(1).join("(").split(":");

        file = storage.standardizePath(components.slice(0, components.length - 2).join(":"));
        line = parseInt(components[components.length - 2]);
        column = parseInt(components[components.length - 1]);

        if (looper === 0) {
            report = {
                "error": error.name,
                "call": name,
                "message": error.message,
                "stack": stack,
                "file": file,
                "line": line,
                "column": column
            };
        }

        ++looper;
    }

    if (functions[file]) {

        var lines = Object.keys(functions[file]).map(parseInt).sort(comparator.numberComparator);

        var lineIndex = maxLessThanOrEqualTo(lines, 0, lines.length, line);
        if (lineIndex !== null) {

            var columns = Object.keys(functions[file][lines[lineIndex]]).map(parseInt).sort(comparator.numberComparator);

            var columnIndex = 0;

            if (lines[lineIndex] === line) {
                columnIndex = maxLessThanOrEqualTo(columns, 0, columns.length, column);
            }

            if (columnIndex !== null) {

                var data = functions[file][lines[lineIndex]][columns[columnIndex]];
                if ((line < data["function"].position.end[0]) ||
                    ((line === data["function"].position.end[0]) && (column < data["function"].position.end[1]))) {

                    report = {
                        "error": error.name,
                        "call": name,
                        "message": error.message,
                        "stack": stack,
                        "file": data["function"].file,
                        "line": line,
                        "column": column
                    };

                    var startLine = Math.max(0, line - data["function"].position.start[0] - 2);

                    var columnOffset = Math.max(column - 40, 0);
                    report.codeLine = data["function"].code.slice(startLine, line - data["function"].position.start[0] + 1).map(function (line, index) {

                        var number = (data["function"].position.start[0] + startLine + index) + "";

                        while (number.length < 6) {
                            number = " " + number;
                        }

                        if (line === data["function"].position.start[0]) {

                            var offset = columnOffset - data["function"].position.start[1];

                            var prefix = "";
                            while (offset < 0) {
                                prefix += " ";
                                ++offset;
                            }

                            return number + "  |  " + prefix + line.substring(offset, offset + 80 - prefix.length);

                        } else {
                            return number + "  |  " + line.substring(columnOffset, columnOffset + 80);
                        }

                    }).join("\n");

                    var correctColumn = column - columnOffset;
                    if (line === data["function"].position.start[0]) {
                        correctColumn -= data["function"].position.start[1];
                    }

                    report.columnArrow = "           ";
                    while (correctColumn > 1) {
                        report.columnArrow += " ";
                        --correctColumn;
                    }
                    report.columnArrow += "^";

                    report["type"] = data["function"].type;
                    report["function"] = data["function"].name;
                    report.author = data["function"].author;
                    report.director = data["function"].director;
                    report.email = data["function"].email;
                    report.company = data["function"].company;
                    report.version = data["function"].version;
                    report.description = data["function"].description;
                    report.usage = data["function"].usage;

                    if (data.module) {
                        report.module = {
                            "name": data.module.name,
                            "author": data.module.author,
                            "director": data.module.director,
                            "email": data.module.email,
                            "company": data.module.company,
                            "version": data.module.version,
                            "description": data.module.description,
                            "usage": data.module.usage
                        };
                    }

                }
            }
        }
    }

    return report;

};

var formatErrorReport = function (report) {

    var result = [report.error + ": " + report.message];

    result.push("------------------------------------------------------------");

    result = result.concat(report.stack);

    var moreInfo = [];

    if (report.file) {
        moreInfo.push("           File: " + report.file);
    }
    if (report.line) {
        moreInfo.push("       Position: Line " + report.line + ", Column " + report.column);
    }
    if (report.call) {
        moreInfo.push("           Call: " + report.call);
    }

    if (report.module && report.module.name) {

        var text =    "         Module: " + report.module.name;
        if (report.module.version) {
            text += " (" + report.module.version + ")";
        }

        moreInfo.push(text);
    }

    if (report["function"]) {
        moreInfo.push("       Function: " + report["function"]);
    }
    if (report.type) {
        moreInfo.push("           Type: " + report.usage);
    }
    if (report.version) {
        moreInfo.push("        Version: " + report.version);
    }
    if (report.usage) {
        moreInfo.push("          Usage: " + report.usage);
    }
    if (report.description) {
        moreInfo.push("    Description: " + report.description);
    }

    if (report.author) {
        moreInfo.push("         Author: " + report.author);
    } else if (report.module && report.module.author) {
        moreInfo.push("         Author: " + report.module.author);
    }

    if (report.email) {
        moreInfo.push("          Email: " + report.email);
    } else if (report.module && report.module.email) {
        moreInfo.push("          Email: " + report.module.email);
    }

    if (report.director) {
        moreInfo.push("       Director: " + report.director);
    } else if (report.module && report.module.director) {
        moreInfo.push("       Director: " + report.module.director);
    }

    if (report.company) {
        moreInfo.push("        Company: " + report.company);
    } else if (report.module && report.module.company) {
        moreInfo.push("        Company: " + report.module.company);
    }

    if (report.codeLine) {
        moreInfo.push("");
        moreInfo.push("Source code");
        moreInfo.push("------------------------------------------------------------");
        moreInfo.push(report.codeLine);
        if (report.columnArrow) {
            moreInfo.push(report.columnArrow);
        }
    }

    if (moreInfo.length > 0) {

        result.push("");
        result.push("Information may be useful for the error");
        result.push("------------------------------------------------------------");

        result = result.concat(moreInfo);

    }

    result.push("");

    return result.join("\n");
};

registerAnnotation("js.namespace", "import", function (namespace) {

    if (!locals[this.file].hasOwnProperty("namespaces")) {
        locals[this.file].namespaces = {};
    }

    if (!locals[this.file].namespaces.hasOwnProperty(this.line)) {
        locals[this.file].namespaces[this.line] = {};
    }

    locals[this.file].namespaces[this.line][this.column] = {
        "action": "import",
        "regex": foundation.convert(namespace, "regex-asterisk-dot")
    };

});

registerAnnotation("js.namespace", "forget", function (namespace) {

    if (!locals[this.file].hasOwnProperty("namespaces")) {
        locals[this.file].namespaces = {};
    }

    if (!locals[this.file].namespaces.hasOwnProperty(this.line)) {
        locals[this.file].namespaces[this.line] = {};
    }

    locals[this.file].namespaces[this.line][this.column] = {
        "action": "forget",
        "regex": foundation.convert(namespace, "regex-asterisk-dot")
    };

});

registerAnnotation("js.common", "local", function (level) {
    return this.get(level);
});

// registerAnnotation("mew.common", "caller", function (scope, level) {
//     return getScopeData(scope.upper, level)
// });

registerAnnotation("js.common", "global", function (name) {
    return this.global[name];
});


registerAnnotation("js.common", "annotate", function (level) {

    var options = {};
    if (arguments.length > 3) {
        options[arguments[2]] = arguments[3];
    } else {
        options = arguments[2];
    }

    return this.put(level, options);

});

["version", "author", "director", "email", "company", "usage", "description"].forEach(function (key) {
    registerAnnotation("js.meta", key, function (value) {
        this.put("*", key, value);
    });
});

// registerAnnotation("", "logger", function (scope, logLevel) {
//     scope.put("*", "logger", {
//         "logLevel": logLevel
//     });
// });

// registerAnnotation("js.level", "file", function (scope, filePath) {
//     scope.put("file", "filePath", filePath);
// });

registerAnnotation("js.level", "module", function (name) {
    this.put("module", "name", name);
});

registerAnnotation("js.level", "function", function (name, type) {
    this.put("function", {
        "name": name,
        "type": type
    });
});

registerAnnotation("js.level", "block", function (name) {
    this.put("block", "name", name);
});

registerAnnotation("js.function", "arguments", function (functionArguments) {
    this.put("function", "arguments", functionArguments);
});

registerAnnotation("js.function", "protected", function (functionProtected) {
    this.put("function", "protected", functionProtected);
});

registerAnnotation("js.function", "monitor", function (monitor, logger) {
    this.put("function", {
        "monitor": monitor,
        "monitorLogger": profileLogger
    });
});

registerAnnotation("js.function", "async", function (async) {
    this.put("function", {
        "async": async
    });
});

registerAnnotation("js.function", "inherits", function (superconstructor) {
    this.put("function", "superconstructor", superconstructor);
});

// registerAnnotation("js.test", "dump", function () {

// });

// logger
// logger.transparent(boolean)
//

registerAnnotation("js.common", "", function (value) {

    if (foundation.isKindOf(value, Function)) {

        var data = this.get();

        data["function"].file = this.file;
        data["function"].position = {
            "start": [this.line, this.column]
        };

        data["function"].code = value.toString().split("\n");
        if (data["function"].code.length > 1) {
            data["function"].position.end = [this.line + data["function"].code.length, data["function"].code[data["function"].code.length - 1].length];
        } else {
            data["function"].position.end = [this.line, this.column + data["function"].code[data["function"].code.length - 1].length];
        }

        if (!functions.hasOwnProperty(data["function"].file)) {
            functions[data["function"].file] = {};
        }

        if (!functions[data["function"].file].hasOwnProperty(data["function"].position.start[0])) {
            functions[data["function"].file][data["function"].position.start[0]] = {};
        }

        if (!functions[data["function"].file][data["function"].position.start[0]].hasOwnProperty(data["function"].position.start[1])) {
            functions[data["function"].file][data["function"].position.start[0]][data["function"].position.start[1]] = data;
        }

        var usedTime = 0;

        var wrapper = function () {

            var start = 0;
            if (data["function"].monitor) {
                start = new Date().getTime();
            }

            if (data["function"].superconstructor) {
                data["function"].superconstructor.apply(this, arguments);
            }

            var result = undefined;
            if (data["function"]["arguments"]) {

                var settings = foundation.matchArguments(
                    data["function"]["arguments"].match,
                    data["function"]["arguments"].fields,
                    arguments);

                result = value.apply(this, [settings]);

            } else {
                result = value.apply(this, arguments);
            }

            if (data["function"].monitor) {
                usedTime += new Date().getTime() - start;
                if (data["function"].monitorLogger) {
                    data["function"].monitorLogger(usedTime);
                }
            }

            return result;

        };

        wrapper.name = value.name;

        wrapper.toString = function () {
            if (data["function"]["protected"]) {
                return "function () { /* protected code */ }";
            } else {
                return value.toString();
            }
        };

        if (data["function"].superconstructor) {
            util.inherits(wrapper, data["function"].superconstructor);
        }

        return wrapper;

    } else {
        return value;
    }

});

var importNamespace = function (file, namespace) {

    var scope = generateAnnotationScope(file);

    if (!locals[scope.file].hasOwnProperty("namespaces")) {
        locals[scope.file].namespaces = {};
    }

    if (!locals[scope.file].namespaces.hasOwnProperty(scope.line)) {
        locals[scope.file].namespaces[scope.line] = {};
    }

    var column = scope.column;
    while (locals[scope.file].namespaces[scope.line].hasOwnProperty(column)) {
        ++column;
    }

    locals[scope.file].namespaces[scope.line][column] = {
        "action": "import",
        "regex": foundation.convert(namespace, "regex-asterisk-dot")
    };

};

var forgetNamespace = function (file, namespace) {

    var scope = generateAnnotationScope(file);

    if (!locals[scope.file].hasOwnProperty("namespaces")) {
        locals[scope.file].namespaces = {};
    }

    if (!locals[scope.file].namespaces.hasOwnProperty(scope.line)) {
        locals[scope.file].namespaces[scope.line] = {};
    }

    var column = scope.column;
    while (locals[scope.file].namespaces[scope.line].hasOwnProperty(column)) {
        ++column;
    }

    locals[scope.file].namespaces[scope.line][column] = {
        "action": "forget",
        "regex": foundation.convert(namespace, "regex-asterisk-dot")
    };

};

module.exports = {

    "analyzeError": analyzeError,
    "formatErrorReport": formatErrorReport,

    "AnnotationKit": {

        "registerAnnotation": registerAnnotation,

        "importNamespace": importNamespace,
        "forgetNamespace": forgetNamespace

    }

};
