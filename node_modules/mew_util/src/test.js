var childProcess = require("child_process");
var fs = require("fs");
var os = require("os");
var path = require("path");

var comparator = require("./comparator.js");
var foundation = require("./foundation.js");
var home = require("./home.js");
var task = require("./task.js");
var storage = require("./storage.js");
var uuid = require("./uuid.js");

var testSignature = "b125458e-848d-40fe-a722-5cdcc5e01620";

var ticks = {};

home.registerUtilConfig("test", {

    "!noLogger": true,

    "testCaseFetchTimeout": { "!valueType": "string", "!defaultValue": 5000 },
    "testCaseTimeout": { "!valueType": "string", "!defaultValue": 5000 },

    "testPath": { "!valueType": "string" },

    "pipeCaseOutput": { "!valueType": "boolean", "!defaultValue": false },
    "caseOutputIsText": { "!valueType": "boolean", "!defaultValue": true },
    "onlyRecordCaseOutputToFile": { "!valueType": "boolean", "!defaultValue": true },

    "tests": { 
        "!valueType": "array",
        "!operation": "union",
        "!stringDelimiter": [",", " "],
        "!ignoreEmptyElement": true,
        "!autotrimString": true,
        "!arrayElement": {
            "!valueType": "string"
        },
        "!defaultValue": []
    },

    // "maxParallelTasks": { "!valueType": "number", "!defaultValue": os.cpus().length },

    "onPackageStarted": { "!valueType": "function", "!operation": "multicall" },
    "onPackageFinished": { "!valueType": "function", "!operation": "multicall" },

    "onUnitStarted": { "!valueType": "function", "!operation": "multicall" },
    "onUnitFinished": { "!valueType": "function", "!operation": "multicall" },

    "onUnitFailed": { "!valueType": "function", "!operation": "multicall" },

    "onCaseStarted": { "!valueType": "function", "!operation": "multicall" },
    "onCaseFinished": { "!valueType": "function", "!operation": "multicall" },

    "onCasePassed": { "!valueType": "function", "!operation": "multicall" }, 
    "onCaseFailed": { "!valueType": "function", "!operation": "multicall" },

    "onCaseOutputted": { "!valueType": "function", "!operation": "multicall" },

    "onProgressReported": { "!valueType": "function", "!operation": "multicall" },

});

var TestKit = function TestKit() {
};

var testKitStarted = false;

TestKit.prototype.boot = function () {

    if (!testKitStarted) {

        var signature = null;
        var packagePath = null;
        var unitPath = null;
        var testCase = null;

        var startDate = new Date();

        process.argv.forEach(function (argument) {
            switch (argument.split("=")[0]) {
                case "--signature": { signature = argument.split("=").slice(1).join("="); break; }
                case "--package-path": { packagePath = argument.split("=").slice(1).join("="); break; }
                case "--unit-path": { unitPath = argument.split("=").slice(1).join("="); break; }
                case "--test-case": { testCase = argument.split("=").slice(1).join("="); break; }
                default: { break; }
            }
        });

        if (signature === testSignature) {

            testKitStarted = true;

            process.on("uncaughtException", function (error) {

                process.send({
                    "signature": testSignature,
                    "action": "reportError",
                    "error": error.message,
                    "stack": foundation.getStack(error)
                });

                task.suicide();

            });

            var testUnit = require(unitPath);

            if (!testCase) {

                var testCases = foundation.keys(testUnit).filter(function (testCase) {
                    return foundation.isKindOf(testUnit[testCase], Function);
                }).map(function (testCase) {
                    return {
                        "testCase": testCase,
                        "timeout": testUnit[testCase].timeout
                    };
                });

                process.send({
                    "signature": testSignature,
                    "action": "reportTestCases",
                    "testCases": testCases
                });

            } else {

                testUnit[testCase](function (error) {

                    if (error) {
                        throw error;
                    } else {
                        process.send({
                            "signature": testSignature,
                            "action": "reportTestCaseFinished",
                            "timeUsed": new Date().getTime() - startDate.getTime(),
                            "passed": !error,
                            "error": {
                                "message": error ? error.message : null,
                                "stack": error ? foundation.getStack(error) : null
                            }
                        });       
                    }

                });

            }

        } else {
            throw new Error("Invalid situation to boot test kit");
        }

    }

};

TestKit.prototype.assert = function (condition, message) {

    if (!testKitStarted) {
        return;
    }

    if (!condition) {

        var error = new Error("Assert failure: " + message);

        process.send({
            "signature": testSignature,
            "action": "reportError",
            "error": error.message,
            "stack": foundation.getStack(error).split("\n").slice(1).join("\n")
        });

        task.suicide();

    }

};

TestKit.prototype.fail = function (message) {

    if (!testKitStarted) {
        return;
    }

    var error = new Error(message);

    process.send({
        "signature": testSignature,
        "action": "reportError",
        "error": error.message,
        "stack": foundation.getStack(error)
    });

    task.suicide();

};

TestKit.prototype.notImpl = function () {

    if (!testKitStarted) {
        return;
    }

    var error = new Error("Not implemented");

    process.send({
        "signature": testSignature,
        "action": "reportError",
        "notImplemented": true,
        "error": error.message,
        "stack": foundation.getStack(error)
    });

    process.exit(1);

};

TestKit.prototype.dump = function (object, level) {

    if (!testKitStarted) {
        return;
    }

    process.send({
        "signature": testSignature,
        "action": "log",
        "level": "dump",
        "message": foundation.jsonize(object, level)
    });

};

TestKit.prototype.debug = function (message) {

    if (!testKitStarted) {
        return;
    }

    process.send({
        "signature": testSignature,
        "action": "log",
        "level": "debug",
        "message": message
    });

};

TestKit.prototype.info = function (message) {

    if (!testKitStarted) {
        return;
    }

    process.send({
        "signature": testSignature,
        "action": "log",
        "level": "info",
        "message": message
    });

};

TestKit.prototype.warn = function (message) {

    if (!testKitStarted) {
        return;
    }

    process.send({
        "signature": testSignature,
        "action": "log",
        "level": "warn",
        "message": message
    });

};

TestKit.prototype.expect = function (value, expected) {

    if (!testKitStarted) {
        return;
    }

    if (value !== expected) {

        var error = new Error("Expected " + foundation.jsonize(expected) + ", but get " + foundation.jsonize(value));

        process.send({
            "signature": testSignature,
            "action": "reportError",
            "error": error.message,
            "stack": foundation.getStack(error)
        });

        task.suicide();

    }

};

var testCase = function (packagePath, unitPath, testCase, timeout, options, callback) {

    if ((!options.testPackages.hasOwnProperty(path.basename(packagePath))) && 
        (!options.testUnits.hasOwnProperty(path.basename(packagePath) + "/" + path.basename(unitPath))) &&
        (!options.testCases.hasOwnProperty(testCase + "@" + path.basename(packagePath) + "/" + path.basename(unitPath)))) {
        callback();
        return;
    }

    var workingPath = path.resolve(packagePath, "tmp", uuid.createUUID());

    storage.copyFile(path.resolve(packagePath, "tmp/origin"), workingPath, function (error) {

        if (error) {

            storage.deleteFile(workingPath, function () {
                callback(error);
            });

        } else {

            var outputWriteStream = fs.createWriteStream(path.resolve(packagePath, "out", path.basename(unitPath), testCase + ".out"));

            options.onCaseStarted(path.basename(packagePath), path.basename(unitPath), testCase);

            var callbacked = false;

            var unit = childProcess.fork(path.resolve(packagePath, "tmp/boot.js"), [
                "--signature=" + testSignature,
                "--package-path=" + packagePath, 
                "--unit-path=" + unitPath,
                "--test-case=" + testCase
            ], {
                "cwd": workingPath,
                "silent": true
            });

            unit.stdout.on("data", function (data) {
                outputWriteStream.write(data);
                options.onCaseOutputted(path.basename(packagePath), path.basename(unitPath), testCase, "stdout", data);
            });

            unit.stderr.on("data", function (data) {
                outputWriteStream.write(data);
                options.onCaseOutputted(path.basename(packagePath), path.basename(unitPath), testCase, "stderr", data);
            });

            var timeoutHandle = setTimeout(function () {

                if (!callbacked) {

                    callbacked = true;

                    task.murder(unit);

                    outputWriteStream.end();

                    storage.deleteFile(workingPath, function () {

                        var error = new Error("Test case has been timeout");

                        error.stack = foundation.getStack(error);

                        options.onCaseFailed(path.basename(packagePath), path.basename(unitPath), testCase, error);

                        options.onCaseFinished(path.basename(packagePath), path.basename(unitPath), testCase);

                        callback();

                    });

                }

            }, timeout ? timeout : options.testCaseTimeout);

            unit.on("message", function (message) {

                if (message && (message.signature === testSignature)) {

                    switch (message.action) {

                        case "log": {

                            options.onCaseLogContent(message.level, message.message);

                            break;

                        }

                        case "reportTestCaseFinished": { 

                            if (!callbacked) {

                                callbacked = true;

                                task.murder(unit);

                                outputWriteStream.end();

                                clearTimeout(timeoutHandle);

                                if (!message.passed) {

                                    var error = new Error(message.error.message);

                                    error.stack = message.error.stack;

                                }

                                storage.deleteFile(workingPath, function () {

                                    options.onCasePassed(path.basename(packagePath), path.basename(unitPath), testCase, message.timeUsed);

                                    options.onCaseFinished(path.basename(packagePath), path.basename(unitPath), testCase);

                                    callback(null);

                                });

                            }

                            break; 
                        }

                        case "reportError": {

                            if (!callbacked) {

                                callbacked = true;

                                task.murder(unit);

                                outputWriteStream.end();

                                clearTimeout(timeoutHandle);

                                var error = new Error(message.error);

                                error.stack = message.stack;
                                error.notImplemented = message.notImplemented;

                                storage.deleteFile(workingPath, function () {

                                    options.onCaseFailed(path.basename(packagePath), path.basename(unitPath), testCase, error);

                                    options.onCaseFinished(path.basename(packagePath), path.basename(unitPath), testCase);

                                    callback();

                                });

                            }

                            break;
                        }

                        default: { break; }
                    }

                }

            });

        }

    });

};

var testUnit = function (packagePath, unitPath, options, callback) {

    if ((!options.testPackages.hasOwnProperty(path.basename(packagePath))) && 
        (!options.coveredUnits.hasOwnProperty(path.basename(packagePath) + "/" + path.basename(unitPath)))) {
        callback();
        return;
    }

    storage.makeDir(path.resolve(packagePath, "out", path.basename(unitPath)), function (error) {

        if (error) {

            callback(error);

        } else {

            options.onUnitStarted(path.basename(packagePath), path.basename(unitPath));

            var callbacked = false;

            var unit = childProcess.fork(path.resolve(packagePath, "tmp/boot.js"), [
                "--signature=" + testSignature,
                "--package-path=" + packagePath, 
                "--unit-path=" + unitPath
            ], {
                "silent": true,
                "cwd": path.resolve(packagePath, "tmp/origin")
            });

            var timeoutHandle = setTimeout(function () {

                if (!callbacked) {

                    callbacked = true;

                    task.murder(unit);

                    var error = new Error("Test unit has been timeout for fetch test cases");

                    options.onUnitFailed(path.basename(packagePath), path.basename(unitPath), error);

                    callback();

                }

            }, options.testCaseFetchTimeout);

            unit.on("message", function (message) {

                if (message && (message.signature === testSignature)) {

                    switch (message.action) {

                        case "reportTestCases": { 

                            if (!callbacked) {

                                callbacked = true;

                                task.murder(unit);

                                clearTimeout(timeoutHandle);

                                var testCases = message.testCases;

                                var looper = 0;
                                var loop = function () {

                                    if (looper < testCases.length) {

                                        ++looper;

                                        testCase(packagePath, unitPath, testCases[looper - 1].testCase, testCases[looper - 1].timeout, options, function (error) {

                                            if (error) {

                                                options.onUnitFinished(path.basename(packagePath), path.basename(unitPath));

                                                callback(error);

                                            } else {
                                                loop();
                                            }

                                        });

                                    } else {

                                        options.onUnitFinished(path.basename(packagePath), path.basename(unitPath));

                                        callback();
                                    }

                                };

                                loop();

                            }

                            break; 
                        }

                        case "reportError": {

                            if (!callbacked) {

                                callbacked = true;

                                task.murder(unit);

                                clearTimeout(timeoutHandle);

                                var error = new Error(message.error);

                                error.stack = message.stack;

                                options.onUnitFailed(path.basename(packagePath), path.basename(unitPath), error);

                                callback();

                            }

                            break;
                        }

                        default: { break; }
                    }

                }

            });

        }

    });

};

var testPackage = function (packagePath, options, callback) {

    if (!options.coveredPackages.hasOwnProperty(path.basename(packagePath))) {
        callback();
        return;
    }

    var tmpPath = path.resolve(packagePath, "tmp/origin");
    fs.exists(tmpPath, function (exists) {

        var output = function () {

            var outputPath = path.resolve(packagePath, "out");

            fs.exists(outputPath, function (exists) {

                if (exists) {
                    storage.deleteFile(outputPath, function (error) {
                        if (error) {
                            callback(error);
                        } else {
                            storage.makeDir(outputPath, common);
                        }
                    });
                } else {
                    storage.makeDir(outputPath, common);
                }

            });

        };

        var common = function (error) {

            var commonPath = path.resolve(packagePath, "../common");

            fs.exists(commonPath, function (exists) {

                if (exists) {

                    fs.stat(commonPath, function (error, stats) {

                        if (stats.isDirectory()) {

                            storage.copyFile(commonPath, tmpPath, function (error) {

                                if (error) {

                                    storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                        callback(error);
                                    });

                                } else {

                                    prepare();

                                }

                            });

                        } else {

                            storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                callback(new Error("Incorrect folder setup for test package"));
                            });

                        }

                    });

                } else {
                    prepare();
                }

            });

        };

        var prepare = function (error) {

            if (error) {

                storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                    callback(error);
                });

            } else {

                fs.writeFile(path.resolve(packagePath, "tmp/boot.js"), "require(\"mew_util\").TestKit.boot();", function (error) {

                    if (error) {

                        storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                            callback(error);
                        });

                    } else {

                        var envPath = path.resolve(packagePath, "env");
                        fs.exists(envPath, function (exists) {

                            if (exists) {

                                fs.stat(envPath, function (error, stats) {

                                    if (error) {

                                        storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                            callback(error);
                                        });

                                    } else {

                                        if (stats.isDirectory()) {
                                            storage.copyFile(envPath, tmpPath, function (error) {

                                                if (error) {

                                                    storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                                        callback(error);
                                                    });

                                                } else {
                                                    start();
                                                }
                                            });
                                        } else {

                                            storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                                callback(new Error("Incorrect folder setup for test package"));
                                            });

                                        }

                                    }

                                });

                            } else {
                                start();
                            }

                        });

                    }

                });

            }

        };

        var start = function () {

            options.onPackageStarted(path.basename(packagePath));

            fs.readdir(packagePath, function (error, files) {

                if (error) {

                    options.onPackageFinished(path.basename(packagePath));

                    storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                        callback(error);
                    });

                } else {

                    var looper = 0;

                    var loop = function () {

                        if (looper < files.length) {
                            ++looper;

                            var fileName = files[looper - 1];
                            if (path.extname(fileName) === ".js") {

                                var casePath = path.resolve(packagePath, fileName);
                                fs.stat(casePath, function (error, stats) {

                                    if (error) {

                                        options.onPackageFinished(path.basename(packagePath));

                                        storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                            callback(error);
                                        });

                                    } else {

                                        if (stats.isFile()) {

                                            testUnit(packagePath, casePath, options, function (error) {

                                                if (error) {

                                                    options.onPackageFinished(path.basename(packagePath));

                                                    storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                                        callback(error);
                                                    });

                                                } else {

                                                    loop();

                                                }
                                            });

                                        } else {
                                            loop();
                                        }

                                    }

                                });

                            } else {
                                loop();
                            }

                        } else {

                            options.onPackageFinished(path.basename(packagePath));

                            storage.deleteFile(path.resolve(packagePath, "tmp"), function () {
                                callback();
                            });

                        }

                    };

                    loop();

                }

            });

        };

        if (exists) {
            storage.deleteFile(tmpPath, function (error) {
                if (error) {
                    callback(error);
                } else {
                    storage.makeDir(tmpPath, output);
                }
            });
        } else {
            storage.makeDir(tmpPath, output);
        }

    });

};

var test = function (testPath, options, callback) {

    if (!callback) {
        callback = function (error) {
            if (error) {
                throw error;
            }
        };
    }

    var options2 = {};
    var configPath = path.resolve(testPath, "conf/test.json");
    fs.exists(configPath, function (exists) {

        var startDate = new Date();

        var start  = function () {

            var testedPackages = {};

            var numberOfNotImplementedCases = 0;
            var numberOfFailedCases = 0;
            var numberOfPassedCases = 0;

            var numberOfFailedUnits = 0;

            var numberOfTestedPackages = 0;
            var numberOfTestedUnits = 0;
            var numberOfTestedCases = 0;

            var createProgressState = function (message, error, milestone) {
                return {

                    "message": message,
                    "error": error,
                    "milestone": milestone ? true : false,

                    "state": "testing",

                    "testStartDate": foundation.convert(startDate, "string"),
                    "timeUsed": ((new Date().getTime() - startDate.getTime()) / 1000).toFixed(3) + "s",

                    "numberOfPassedCases": numberOfPassedCases,
                    "numberOfFailedCases": numberOfFailedCases,
                    "numberOfNotImplementedCases": numberOfNotImplementedCases,
                    "numberOfFailedUnits": numberOfFailedUnits,
                    "numberOfTestedPackages": numberOfTestedPackages,
                    "numberOfTestedUnits": numberOfTestedUnits,
                    "numberOfTestedCases": numberOfTestedCases,

                };
            };

            options = home.getUtilConfigSync("test", null, {

                "onPackageStarted": function (testPackage) {

                    ++numberOfTestedPackages;

                    testedPackages[testPackage] = {
                        "state": "testing",
                        "units": {}
                    };

                    options.onProgressReported(createProgressState("Start to test package[" + testPackage + "]"));

                },

                "onPackageFinished": function (testPackage) {

                    testedPackages[testPackage].state = "tested";

                    options.onProgressReported(createProgressState("Test package[" + testPackage + "] finished"));

                },

                "onUnitStarted": function (testPackage, testUnit) {

                    ++numberOfTestedUnits;

                    testedPackages[testPackage].units[testUnit] = {
                        "state": "testing",
                        "cases": {}
                    };

                    options.onProgressReported(createProgressState("Start to test unit[" + testPackage + "/" + testUnit + "]"));

                },

                "onUnitFinished": function (testPackage, testUnit) {

                    testedPackages[testPackage].units[testUnit].state = "tested";

                    options.onProgressReported(createProgressState("Test unit[" + testPackage + "/" + testUnit + "] finished"));

                },

                "onUnitFailed": function (testPackage, testUnit, error) {

                    ++numberOfFailedUnits;

                    testedPackages[testPackage].units[testUnit].state = "failed";

                    options.onProgressReported(createProgressState("Test unit[" + testPackage + "/" + testUnit + "] failed", error));

                },

                "onCaseStarted": function (testPackage, testUnit, testCase) {

                    ++numberOfTestedCases;

                    testedPackages[testPackage].units[testUnit].cases[testCase] = {
                        "state": "testing",
                        "passed": false,
                        "outputFile": testPackage + "/" + testUnit + "/" + testCase + ".out",
                        "output": []
                    };

                    options.onProgressReported(createProgressState("Start to test case[" + testCase + "@" + testPackage + "/" + testUnit + "]"));

                },

                "onCaseFinished": function (testPackage, testUnit, testCase) {

                    testedPackages[testPackage].units[testUnit].cases[testCase].state = "tested";

                    if (options.onlyRecordCaseOutputToFile) {

                        delete testedPackages[testPackage].units[testUnit].cases[testCase].output;

                    } else {

                        testedPackages[testPackage].units[testUnit].cases[testCase].output = Buffer.concat(testedPackages[testPackage].units[testUnit].cases[testCase].output);

                        if (options.caseOutputIsText) {
                            testedPackages[testPackage].units[testUnit].cases[testCase].output.encoding = "utf8";
                            testedPackages[testPackage].units[testUnit].cases[testCase].output = testedPackages[testPackage].units[testUnit].cases[testCase].output.toString();
                        }

                    }
     
                    options.onProgressReported(createProgressState("Test case[" + testCase + "@" + testPackage + "/" + testUnit + "] finished"));

                },

                "onCasePassed": function (testPackage, testUnit, testCase, timeUsed) {

                    ++numberOfPassedCases;

                    testedPackages[testPackage].units[testUnit].cases[testCase].passed = true;

                    options.onProgressReported(createProgressState("Test case[" + testCase + "@" + testPackage + "/" + testUnit + "] passed, " + (timeUsed / 1000).toFixed(3) + "s used", null, true));

                },

                "onCaseFailed": function (testPackage, testUnit, testCase, error) {

                    ++numberOfFailedCases;

                    if (error.notImplemented) {
                        ++numberOfNotImplementedCases;
                    }

                    testedPackages[testPackage].units[testUnit].cases[testCase].passed = false;
                    testedPackages[testPackage].units[testUnit].cases[testCase].error = {
                        "message": error.message,
                        "stack": error.stack,
                        "notImplemented": error.notImplemented
                    };

                    if (error.notImplemented) {
                        options.onProgressReported(createProgressState("Test case[" + testCase + "@" + testPackage + "/" + testUnit + "] failed for no implementation", error));
                    } else {
                        options.onProgressReported(createProgressState("Test case[" + testCase + "@" + testPackage + "/" + testUnit + "] failed", error));
                    }

                },

                "onCaseOutputted": function (testPackage, testUnit, testCase, channel, data) {

                    if (options.pipeCaseOutput) {
                        process[channel].write(data);
                    }

                    if (!options.onlyRecordCaseOutputToFile) {
                        testedPackages[testPackage].units[testUnit].cases[testCase].output.push(data);
                    }

                },

                "onCaseLogContent": function (level, message) {
                    // Do nothing
                },

                "onProgressReported": function (state) {
                    // Do nothing
                }

            }, options2, options, {
                "testPath": testPath,
            });

            options.onProgressReported(createProgressState("Start to test"));

            options.testPackages = {};
            options.testUnits = {};
            options.testCases = {};

            options.coveredPackages = {};
            options.coveredUnits = {};

            if (options.tests.length > 0) {

                options.tests.forEach(function (test) {

                    var rawTest = test;

                    var testPackage = null;
                    var testUnit = null;
                    var testCase = null;

                    var pair = test.split("@");
                    if (pair.length > 1) {
                        testCase = pair[0];
                        test = pair.slice(1).join("@");
                    }

                    pair = test.split("/");
                    if (pair.length > 1) {
                        testPackage = pair[0];
                        testUnit = pair.slice(1).join("/");
                    } else {
                        testPackage = test;
                    }

                    if ((testCase && ((!testUnit) || (!testPackage))) || (testUnit && (!testPackage))) {
                        callback(new Error("Invalid test name: " + rawTest));
                    } else {

                        if (testPackage) {

                            options.coveredPackages[testPackage] = true;

                            if (!testUnit) {
                                options.testPackages[testPackage] = true;
                            }
                        }

                        if (testUnit) {
                            options.coveredUnits[testPackage + "/" + testUnit] = true;
                            if (!testCase) {
                                options.testUnits[testPackage + "/" + testUnit] = true;
                            }
                        }

                        if (testCase) {
                            options.testCases[testCase + "@" + testPackage + "/" + testUnit] = true;
                        }

                    }

                });

            }

            var outputPath = path.resolve(testPath, "test", "out");

            fs.exists(outputPath, function (exists) {

                var testPackages = function (error) {

                    if (error) {

                        callback(error);

                    } else {

                        var packages = fs.readdirSync(path.resolve(testPath, "test")).filter(function (name) {
                            return (name !== "env") && (name !== "out");
                        });

                        if (options.tests.length == 0) {
                            packages.forEach(function (testPackage) {
                                options.testPackages[testPackage] = true;
                                options.coveredPackages[testPackage] = true;
                            });
                        }

                        var looper = 0;
                        var testOnePackage = function () {

                            if (looper < packages.length) {

                                ++looper;

                                testPackage(path.resolve(testPath, "test", packages[looper - 1]), options, function (error) {

                                    if (error) {
                                        callback(error);
                                    } else {

                                        if (!options.coveredPackages.hasOwnProperty(packages[looper - 1])) {

                                            testOnePackage();

                                        } else {

                                            fs.rename(path.resolve(testPath, "test", packages[looper - 1], "out"), path.resolve(testPath, "test", "out", packages[looper - 1]), function (error) {
                                                if (error) {
                                                    callback(error);
                                                } else {
                                                    testOnePackage();
                                                }
                                            });

                                        }

                                    }

                                });

                            } else {

                                var endDate = new Date();

                                var report = {
                                    "testType": "complete",
                                    "testPath": testPath,
                                    "allPassed": (numberOfFailedCases === 0) && (numberOfFailedUnits === 0),
                                    "state": "tested",
                                    "testStartDate": foundation.convert(startDate, "string"),
                                    "testEndDate": foundation.convert(endDate, "string"),
                                    "timeUsed": ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + "s",
                                    "numberOfPassedCases": numberOfPassedCases,
                                    "numberOfFailedCases": numberOfFailedCases,
                                    "numberOfNotImplementedCases": numberOfNotImplementedCases,
                                    "numberOfFailedUnits": numberOfFailedUnits,
                                    "numberOfTestedPackages": numberOfTestedPackages,
                                    "numberOfTestedUnits": numberOfTestedUnits,
                                    "numberOfTestedCases": numberOfTestedCases,
                                    "packages": testedPackages,
                                    "os": {
                                        "type": os.type(),
                                        "version": os.release(),
                                        "name": os.hostname()
                                    }
                                };

                                if (options.tests.length > 0) {
                                    report.testType = "filtered";
                                    report.tests = options.tests.slice(0).sort(comparator.insensitiveNaturalComparator);
                                }

                                fs.writeFile(path.resolve(testPath, "test", "out", "report.json"), JSON.stringify(report, null, 4), function (error) {

                                    options.onProgressReported(createProgressState("Test finished"));

                                    if (error) {
                                        callback(error);
                                    } else {
                                        callback(null, report);
                                    }

                                });

                            }

                        };

                        testOnePackage();

                    }

                };

                if (exists) {
                    storage.deleteFile(outputPath, function (error) {
                        if (error) {
                            callback(error);
                        } else {
                            storage.makeDir(outputPath, testPackages);
                        }
                    });
                } else {
                    storage.makeDir(outputPath, testPackages);
                }

            });

        };

        if (exists) {

            fs.readFile(configPath, function (error, content) {

                if (error) {
                    callback(error);
                } else {

                    try {
                        options2 = JSON.parse(content.toString("utf8"));
                    } catch (error) {
                        callback(new Error("Failed to parse JSON file at path: " + configPath + "\n" + error.message));
                        return;
                    }

                    if (testPath === home.getUtilHomeDir()) {
                        options2 = {};
                    }

                    start();

                }

            });

        } else {
            start();
        }

    });

};

module.exports = {
    "test": test,
    "TestKit": new TestKit()
};

