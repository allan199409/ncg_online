var net = require("net");
var os = require("os");

// Get broadcast IPs
//   -> currently only IPv4
//
var getBroadcastIPs = function () {

    var interfaces = os.networkInterfaces();

    var broadcastIPs = [];

    var isNameAcceptable = function (name) {

        if (process.platform.toLowerCase() === "win32") {
            return true;
        } else {
            return /^(en|eth|wlan)/.test(name);
        }

    };

    Object.keys(interfaces).forEach(function (name) {

        if (isNameAcceptable(name)) {

            interfaces[name].forEach(function (interface) {

                if ("IPv4" === interface.family) {

                    if (!interface.internal) {

                        var netmask = interface.netmask;
                        if (!netmask) {
                            netmask = "255.255.255.0";
                        }

                        var masks = netmask.split(".").map(function (text) {
                            return parseInt(text);
                        });

                        broadcastIPs.push(interface.address.split(".").map(function (text, index) {
                            return (((~masks[index]) & 0xff) | parseInt(text)) + "";
                        }).join("."));

                    }

                }

            });

        }

    });

    return broadcastIPs;
};

// Get host IPs
//
var getHostIPs = function(onlyInternal, ipV6) {

    var interfaces = os.networkInterfaces();

    var internalIPs = [];
    var externalIPs = [];

    Object.keys(interfaces).forEach(function (name) {

        if ((/^(lo|en|eth|wlan)/.test(name)) || (process.platform.substring(0, 3) === "win")) {

            interfaces[name].forEach(function (interface) {

                if ((ipV6 && ("IPv6" === interface.family)) ||
                    ((!ipV6) && ("IPv4" === interface.family))) {

                    if (interface.internal) {
                        internalIPs.push(interface.address);
                    } else {
                        externalIPs.push(interface.address);
                    }

                }

            });

        }

    });

    if (onlyInternal) {
        return internalIPs;
    } else {
        return externalIPs.slice(0).concat(internalIPs);
    }

};

// Find port for sockets
//
// -> findAvialablePort(callback)
// -> findAvialablePort(options)
// -> findAvialablePort(options, callback)
//
var findAvialablePort = function () {

    var options = null;
    var callback = null;

    if (arguments[0]) {

        if (arguments[0].constructor === Function) {
            callback = arguments[0];
        } else {
            options = arguments[0];
        }

    }

    if (arguments[1] && arguments[1].constructor === Function) {
        options = arguments[0];
        callback = arguments[1];
    }

    if (!options) {
        options = {};
    }

    var getNextPort = function (port) {
        return port + 1;
    };

    if (options.getNextPort) {
        getNextPort = options.getNextPort;
    }

    options.port = parseInt(options.port);
    if (isNaN(options.port)) {
        options.port = 8000;
    }

    if ((!options.host) || (options.host.constructor !== String)) {
        options.host = null;
    }

    if (!options.server) {
        options.server = net.createServer(function () {});
    }

    var onListen = function () {
        options.server.removeListener("error", onError);
        options.server.close();
        callback(null, options.port);
    };

    var onError = function (error) {

        options.server.removeListener("listening", onListen);

        if (error.code !== "EADDRINUSE") {
            return callback(err);
        }

        findAvialablePort({
            "port": getNextPort(options.port),
            "host": options.host,
            "server": options.server
        }, callback);

    };

    options.server.once("error", onError);
    options.server.once("listening", onListen);

    options.server.listen(options.port, options.host);

};

module.exports = {
    "getHostIPs": getHostIPs,
    "getBroadcastIPs": getBroadcastIPs,
    "findAvialablePort": findAvialablePort
};
