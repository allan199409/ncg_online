var shortcutSymbols = ["@","$"];
var annotation = {};
if ((process.arch !== "js") && global.Proxy) {
    annotation = require("./annotation.js");
} else {

    shortcutSymbols = ["$"];
}

shortcutSymbols.forEach(function(shortcutSymbol){
    if (!global[shortcutSymbol]) {
        global[shortcutSymbol] = {};
    }
})

//var chan = require("./chan.js");
var comparator = require("./comparator.js");
var foundation = require("./foundation.js");
var home = require("./home.js");
var network = require("./network.js");
var plugin = require("./plugin.js");
var storage = require("./storage.js");
var stream = require("./stream.js");
var task = require("./task.js");
var template = require("./template.js");
var test = require("./test.js");
var uuid = require("./uuid.js");
var ruler = require('./ruler.js');
var async = require("./async.js");

var mimes = require("./mimes.js");

//var Logger = require("./logger.js");
var HTTPClient = require("./http_client.js");
var HTTPKittyClient = require("./http_kitty.js");
var CachePool = require("./cache_pool.js");

[
    annotation, comparator, foundation,
    home, network, plugin, storage,
    stream, task, template, test, uuid
].forEach(function (submodule) {
    foundation.keys(submodule).forEach(function (key) {
        module.exports[key] = submodule[key];
    });
});

module.exports.async = async;
module.exports.ruler = ruler;
module.exports.isAsync = async.isAsync;

module.exports.mimes = mimes;

//module.exports.Logger = Logger;
module.exports.HTTPClient= HTTPClient;
module.exports.CachePool = CachePool;
module.exports.HTTPKittyClient = HTTPKittyClient;

// Object.defineProperty(module.exports, "preparedJSCodesForCombination", {
//     "enumerable": false,
//     "value": chan.preparedJSCodesForCombination
// });

[

    "async",

    "isNull",
    ["is", "isKindOf"],

    ["as", "convert"],
    ["as.possible", "couldBeAcceptedAs"],

    "matchArguments",

    "simplify",
    "objectize",

    "jsonize",

    "keys",
    ["property", "getProperty"],
    ["index", "getIndex"],

    "merge",
    ["merge.advanced", "advancedMerge"],

    ["iterate.array", "iterateArray"],
    ["iterate.object", "iterateObject"],

    ["comparator", "generatePathComparator"],
    ["comparator.number", "numberComparator"],
    ["comparator.date", "dateComparator"],
    ["comparator.string", "stringComparator"],
    ["comparator.natural", "naturalComparator"],
    ["comparator.natrual.insensitive", "insensitiveNaturalComparator"],

    ["memory.CachePool", "CachePool"],

    ["module.plugin", "plugin"],
    ["module.require", "requireModule"],
    ["module.resolve", "resolveModule"],

    ["uuid", "createUUID"],

    "format",
    ["format.date", "formatDate"],

    ["fs.makeDir", "makeDir"],
    ["fs.makeDirSync", "makeDirSync"],
    ["fs.makeDirs", "makeDirTree"],

    ["fs.copyFile", "copyFile"],
    ["fs.copyFileSync", "copyFileSync"],

    ["fs.deleteFile", "deleteFile"],
    ["fs.deleteFileSync", "deleteFileSync"],

    ["fs.scanFile", "scanFile"],
    ["fs.scanFileSync", "scanFileSync"],

    ["fs.homeDir", "getHomeDir"],
    ["fs.tempDir", "getTempDir"],

    ["net.avialablePort", "findAvialablePort"],
    ["net.hostIPs", "getHostIPs"],
    ["net.broadcastIPs", "getBroadcastIPs"],

    ["net.HTTPClient", "HTTPClient"],

    ["stream.readable", "createReadable"],
    ["stream.buffer", "getAllRestBuffer"],

    ["task.suicide", "suicide"],
    ["task.murder", "murder"],
    ["task.execute", "executeCommand"]

].forEach(function (key) {

    shortcutSymbols.forEach(function(shortcutSymbol){
        if (foundation.isKindOf(key, Array)) {

            var key1 = key[0].split(".");
            var key2 = key[1].split(".");

            var target = global[shortcutSymbol];
            key1.forEach(function (subkey1, index, key1) {

                if (index < key1.length - 1) {

                    if (!target[subkey1]) {
                        target[subkey1] = {};
                    }

                    target = target[subkey1];

                } else {

                    var source = module.exports;
                    key2.forEach(function (subkey2, index, key2) {
                        source = source[subkey2];
                    });

                    target[subkey1] = source;

                }

            });

        } else {
            global[shortcutSymbol][key] = module.exports[key];
        }
    });

});


shortcutSymbols.forEach(function(shortcutSymbol){
    global[shortcutSymbol].mewchan = null;
});

//var logger = new Logger();

// Uncaught exceptions
//
// process.on("uncaughtException", function (error) {
//
//     if (!error.processed) {
//
//         try {
//
//             var report = annotation.analyzeError(error);
//             if (report) {
//
//                 var verbose = annotation.formatErrorReport(report);
//
//                 logger.error(verbose);
//
//             } else {
//                 logger.error(error);
//             }
//
//         } catch (error2) {
//
//             logger.error("Failed to generate error report");
//             logger.error(error2);
//
//             logger.error("Source error");
//             logger.error(error);
//
//         }
//
//         task.suicide();
//
//     } else {
//
//         process.exit();
//
//     }
//
// });
